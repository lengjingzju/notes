# C/C++编程笔记

## 目录

[TOC]

## 核心概念

### 数据和算法

* 数据是程序处理的对象，C++通过数据类型定义数据的存储结构、取值范围及可执行操作
    * 一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算
    * 变量的类型决定了变量的内存大小和布局、能够存储于该内存中的值的取值范围以及可应用在该变量上的操作集
* 算法是解决特定问题的有限指令序列，需满足明确性、有穷性、输入/输出、有效性四大特性

### 机制和策略

机制与策略分离是一种核心设计哲学，实现底层实现(机制)与上层决策(策略)解耦，从而提升系统的灵活性、可维护性和可扩展性

* 机制(Mechanism)：底层能力提供者，机制是系统/库提供的基础功能，负责“能做什么”
* 策略(Policy)：上层决策与定制，策略定义“如何做”，基于机制组合实现具体功能，通常在顶层应用配置，灵活可替换

### 编程模式

* 自顶向下(top-down)的设计
    * 在C语言中，其理念是将大型程序分解成小型、便于管理的任务
    * 如果其中的一项任务仍然过大，则将它分解为更小的任务
    * 这一过程将一直持续下去，直到将程序划分为小型的、易于编写的模块函数
<br>

* 结构化编程(Structured Programming)
    * 强调算法，使用自顶向下、代码分层抽象的核心思想
    * 仅使用三种基本控制结构(顺序、分支、循环)组合程序逻辑，避免使用goto语句
    * 使用模块化设计，将复杂系统分解为独立的功能模块，每个模块职责单一，通过接口组合实现整体功能
<br>

* 面向对象编程(OOP: Object-Oriented Programming)
    * 强调数据，其理念是设计与问题的本质特性相对应的数据格式，包含数据(属性)和操作数据的方法(行为)
    * 在C++中，通过类(Class)定义对象的模板，通过实例化(Instantiation)创建具体对象
    * OOP的核心思想是数据抽象(封装)、数据复用(继承)和动态绑定(多态)
        * 封装(Encapsulation)：将数据和操作捆绑在一起，隐藏内部实现细节，仅暴露接口
        * 继承(Inheritance)：子类自动共享父类的属性和方法，实现代码重用
        * 多态(Polymorphism)：同一操作程序运行时根据对象实际类型(虚函数表)动态绑定方法
        * 重载(Overloading)：在编译阶段根据函数参数确定具体调用的方法(狭义多态不含重载)
<br>

* 泛型编程(Generic Programming)
    * 强调独立于特定数据类型
    * 在C++中，使用模板进行泛型编程
    * 泛型编程提供了执行常见任务(如对数据排序或合并链表)的工具

### C++风格

* 宏
    * 几乎不使用宏
    * 用 `const` 或 `enum` 定义明显的常量
    * 用 `inline` 避免函数调用的额外开销(C99也支持)
    * 用 `template` 去刻画一族函数或类型
    * 用 `namespace` 去避免名字冲突
* 定义和声明
    * 不需要把声明放在块语句开头，要保证声明后立即对它初始化和使用(C99也支持)
    * C++/C11 定义可以出现在for语句的初始化部分
    * C++17 定义可以出现在if/switch语句中
* 内存
    * 不要使用 `malloc()` 和 `free()`，而是使用 `new` 和 `delete` (原因是malloc/free不能自动调用构造/析构函数)
    * 对于 realloc()，可以使用 `vector`
    * 避免 `void *`、指针运算、联合和强制转换
* 数组字符串
    * 采用 `vector` 和 `迭代器` 取代一般的数组
    * 采用 `string` 取代C风格字符串
* 链接
    * 如果要符合C的链接规则，一个C++函数必须被声明为具有C链接的
    ```cxx
    #ifdef __cplusplus
    extern "C" {
    #endif
    /* 函数或变量声明、#include 头文件等 */
    #ifdef __cplusplus
    }
    #endif
    ```
    * 也可以单个声明，例如 `extern "C" 函数或变量声明;`
* 比较
    * 习惯于优先选用 `!=` 而不是 `<` 来编写循环判断条件，因为在C++中，有些数据结构(如vector)可以动态增长

### 宏定义

#### 宏替换

* `#define NAME (value)` ：简单宏替换，注意没用分号 `;` 结尾
    * 注：gcc编译时可以 `-Dname` `-Dname=value` 定义宏，没有value时默认值是1
* `#define FUNC(a, b) (expr)` ：带参数的宏替换，不用传类型
    * 宏替换列表不能用重载和递归，expr可用 `##` 拼接两个串，变为新串
* `#undef NAME` ：取消宏定义

    ```c
    // 宏替换定义一个错误打印
    #define LLOG_ERROR(fmt, ...) fprintf(stderr, "E: %s:%d " fmt, __func__, __LINE__, ##__VA_ARGS__)
    ```

    ```c
    // uvc_configfs.c中用 `##` 拼接两个串，变为新串
    #define UVC_ATTR(prefix, cname, aname) \
    static struct configfs_attribute prefix##attr_##cname = { \
    	.ca_name	= __stringify(aname),				\
    	.ca_mode	= S_IRUGO | S_IWUGO,				\
    	.ca_owner	= THIS_MODULE,					\
    	.show		= prefix##cname##_show,				\
    	.store		= prefix##cname##_store,			\
    }
    ```

#### 条件编译宏

条件编译宏是预处理时选择分支而不是运行时选择

* 根据宏名的值是否为真进入不同分支

    ```c
    #if 表达式
    //程序段
    #elif 宏名
    //程序段
    #else
    //程序段
    #endif
    ```

* 根据宏名是否定义进入不同分支
    * `#ifdef 宏名` 等效 `#if defined(宏名)`
    * `#ifdef 宏名` 相反写法是 `#ifndef 宏名`
    * `#elifdef` 和 `#elifndef` 为C++23/C23新增

    ```c
    #ifdef 宏名
    //程序段
    #elifdef 宏名
    //程序段
    #else
    //程序段
    #endif
    ```

* 只包含头文件一次

    | 特性         | `#pragma once`                           | `#ifndef` 宏保护                        |
    | ------------ | ---------------------------------------- | ---------------------------------------- |
    | 兼容性       | 非标准指令，主流编译器(GCC、Clang、MSVC)支持，但老旧编译器可能不支持 | C/C++ 标准支持，所有编译器兼容 |
    | 防护范围     | 仅针对物理文件(相同路径的文件) | 针对宏定义(可防护内容相同但文件名不同的头文件) |
    | 编译性能     | 更高：编译器直接记录文件路径，无需重复打开文件 | 较低：每次包含都需打开文件检查宏定义 |
    | 命名冲突风险 | 无(无需定义宏) | 有(宏名需全局唯一，否则导致声明跳过或编译错误) |

    ```c
    #pragma once
    /* 头文件内容 */
    ```

    ```c
    #ifndef __XXX_H__
    #define __XXX_H__
    /* 头文件内容 */
    #endif
    ```

#### 断言宏

用于预处理。

* `#error "错误信息"` ：强制编译器报错并终止编译，用于检查不满足的编译条件`
* `#warning "警告信息"` ：输出编译警告但不终止编译，提示潜在问题(C++23/C23)

#### 调试宏

* `__func__` ：值为字符串，替换为当前函数名
* `__FILE__` ：值为字符串，替换为当前源文件名
* `__LINE__` ：值为整数，替换为当前行号
* `__DATE__` ：值为字符串，替换为编译日期
* `__TIME__` ：值为字符串，替换为编译时间

#### 语言宏

* `__cplusplus` ：使用C++编译器编译

#### 编译器检测宏

* GCC
    * `__GNUC__` ：主版本号
    * `__GNUC_MINOR__` ：次版本号
    * `__GNUC_PATCHLEVEL__` ：补丁版本号
* Clang
    * `__clang_major__` ：主版本号
    * `__clang_minor__` ：次版本号
    * `__clang_patchlevel__` ：补丁版本号
* MSVC
    * `_MSC_VER` ：完整版本号(VS2022的值为1930)
    * `_MSC_FULL_VER` ：含补丁详细版本号

#### 操作系统检测宏

* Windows
    * `_WIN32` ：32/64位Windows均定义
    * `_WIN64` ：仅64位Windows定义
* Linux/Unix
    * `__linux__` ：Linux系统标识。
    * `__unix__` or ` __unix` ：Unix标准系统(含Linux/macOS)
* macOS/iOS
    * `__APPLE__` ：Apple平台标识
    * `__MACH__` ：MacOS专用标识(常与 `__APPLE__` 联用)
* Android
    * `__ANDROID__` ：Android系统标识

#### 处理器检测宏

* x86/x64
    * `__i386__` ：32位x86架构
    * `__x86_64__` or `_M_X64` ：64位x86架构
* ARM
    * `__arm__` or `_M_ARM` ：32位ARM架构
    * `__aarch64__` or `__arm64__` ：64位ARM架构

## 入门实例

### 基本概念

* 变量和函数命名规则：
    * 只能使用字母字符、数字和下划线且第一个字符不能是数字
    * 区分大写字符与小写字符
    * 不能将关键字用作名称

* 代码注释
    ```cxx
    // 行注释，直到行尾

    /*
     * 多行注释，不允许嵌套
     */
    ```

* 头文件包含
    * 头文件可以定义对象类型(复合类型、C++类等)、值在编译时就已知道的 `const` 对象和 `inline` 函数
    * 对象实例和函数实现在源文件中定义(C++头文件类内部实现的函数自动 `inline` )
    * 标准库的头文件用尖括号 `< >` 括起来，非标准库的头文件用双引号 `" "` 括起来
    * C++程序中调用C标准库头文件时应采用 `cname` 方式，但也可使用 `name.h` 方式

* 函数传参和返回
    * 函数参数列表为空括号时，C意味着对是否接受参数保持沉默，C++意味着参数为空
        * C参数列表为空要用 `void` 说明，C23空括号已定义为非法语法
    * 函数省略返回类型时，C相当于说返回类型为int(有警告)，C++无此用法
    * C不支持默认参数(结构体默认参数，函数传参默认参数)，C++支持
    * main函数末尾时没有遇到返回语句，则认为main函数到达末尾返回0

* 标准输入输出
    * stdin 标准输入，文件描述符为0
    * stdout 标准输出，文件描述符为1
    * stderr 标准错误，文件描述符为2

### C stdio.h

```c
#include <stdio.h>
int main(void)
{
    int v1, v2;
    printf("Enter two numbers:\n");
    scanf("%d %d", &v1, &v2);

    printf("The sum of %d and %d v2 is %d\n", v1, v2, v1 + v2);

    return 0;
}
```

### C++ iostring

```cxx
#include <iostream>
using namespace std;
int main()
{
    int v1, v2;
    std::cout << "Enter two numbers:" << std::endl;
    std::cin >> v1 >> v2;
    std::cout << "The sum of " << v1 << " and " << v2
            << " is " << v1 + v2 << std::endl;

    int sum = 0, value;
    while(std::cin >> value)
        sum += value; // equivalent to sum = sum + value
    std::cout << "Sum is: " << sum << std::endl;

    return 0;
}
```

* 前缀 `std::`
    * 使用命名空间 `namespace` 可以避免与库中定义的名字相同而引起无意冲突
    * 作用域操作符(scope operator `::`)，表示使用的是定义在命名空间 `std` 中的 `cout`
* 输入输出
    * cin 标准输入：用于从标准输入中读入的istream对象
    * cout标准输出：用于写入到标准输出的ostream对象，一般情况下用于程序的输出
    * cerr标准错误：错误和警告信息，默认情况下，输出cerr不缓冲
    * `endl` 是一个特殊值，称为操纵符，将它写入输出流时，具有输出换行的效果，并刷新与设备相关联的缓冲区
        * `endl` 确保程序继续运行前刷新输出(将其立即显示在屏幕上)；而使用 `\n` 不能提供这样的保证
* 操作符
    * 输出操作符(`<<`)接受两个操作数：左操作数必须是ostream 对象，右操作数是要输出的值
        * 操作符将其右操作数写到作为其左操作数的ostream对象。
    * 输入操作符(`>>` 操作符)接受一个istream对象作为其左操作数，接受一个对象作为其右操作数
        * 它从istream操作数读取数据并保存到右操作数中，输入操作符返回其左操作数作为结果
    * `while(std::cin >> value)` 测试流的状态
        * 如果流是有效的(即读入下一个输入是可能的)那么测试成功
        * 遇到文件结束符或遇到无效输入时，则istream对象是无效的，处于无效状态的istream对象将导致条件失败
        * 操作系统使用不同的值作为文件结束符：Windows系统通常用 `ctrl+z` 键，Unix系统中通常用 `Ctrl+d`

## 运算优先级

| operater                  | description             |
| ------------------------- | ----------------------- |
| **01** 作用域(L-R)                                 ||
| `::`                      | 作用域解析(C++)         |
| **02** 一元(L-R)                                   ||
| `->` `.`                  | 成员访问                |
| `type(expr)` `type{expr}` | 函数风格类型转换(C++)   |
| `(  )`                    | 函数调用                |
| `[  ]`                    | 数组下标                |
| `{  }`                    | 组合块                  |
| `++`  `--`                | 自增/自减后缀           |
| **03** 一元(R-L)                                   ||
| `&`   `*`                 | 取地址/解引用           |
| `++`  `--`                | 自增/自减前缀           |
| `+`   `-`                 | 正号/负号               |
| `~`   `!`                 | 位非/逻辑非             |
| `(type)expr`              | C风格类型转换           |
| `sizeof`                  | 字节长度                |
| `co_await`                | 协程(C++20)             |
| `new` / `new[]`           | 动态分配元素/数组(C++)  |
| `delete` / `delete[]`     | 动态释放元素/数组(C++)  |
| **04** 成员解引用(L-R)                             ||
| `.*` `->*`                | 成员解引用(C++)         |
| **05** 算术乘除余(L-R)                             ||
| `*`   `/`   `%`           | 乘/除/余                |
| **06** 算术加减(L-R)                               ||
| `+`  `-`                  | 加/减                   |
| **07** 移位(L-R)                                   ||
| `<<`  `>>`                | 左移/右移               |
| **08** 三路比较(L-R)                               ||
| `<=>`                     | 三路比较(C++20)         |
| **09** 比大小(L-R)                                 ||
| `<`  `<=`  `>`  `>=`      | 比大小                  |
| **10** 比相等(L-R)                                 ||
| `==`  `!= `               | 比相等                  |
| **11-13** 位逻辑(L-R)                              ||
| `&`  `^`  `\|`            | 按位与/异或/或          |
| **14-15** 逻辑(L-R)                                ||
| `&&`  `\|\|`              | 与/或                   |
| **16** 条件和赋值(R-L)                             ||
| `cond?expr1:expr2`        | 条件运算                |
| `=`                       | 赋值                    |
| `*=` `/=` `%=` `+=` `-=`  | 算术运算复合赋值       |
| `<<=`  `>>=`              | 移位运算复合赋值        |
| `&=`  `^=`  `\|=`         | 位逻辑运算复合赋值      |
| `throw`                   | 抛出异常(C++)           |
| `co_yield`                | 协程(C++20)             |
| **17** 逗号(L-R)                                   ||
| `,`                       | 逗号表达式              |

* 17个等级优先级
    * 值越小优先级越高，同优先级按结合顺序是从左往右(L-R)还是从右往左(R-L)
    * 可用小括号 `()` 改变结合的优先级
* `++` `--`
    * 前缀自增自减，运算后返回运算后的值
    * 后缀自增自减，返回运算前的值并做运算
    * 一个变量同时出现在一个函数的多个参数中或多次出现在同一个表达式中，不要使用自增自减
* 正负数计算
    * 如果两个操作数都是正数，除法 `/` 和求模 `%` 的值都是正数(或零)
    * 如果两个操作数都是负数，除法的值是正数(或零)，求模的值是负数(或零)
    * 如果只有一个操作数是负数，除法的值是负数(或零)，求模的值取决于机器
        * 一般除法是向0取整(C++11新标准)，例如 `10/(-4)=-2`, `(-10)/4=-2`, `10%(-4)=2`, `(-10)%4=-2`
    * 有符号右移 `>>` 用符号位还是0填充由C++决定(大多数情况是高位补符号位)
* 短路求值和逗号表达式
    * `&&` 左边为假，右边不再求值
    * `||` 左边为真，右边不再求值
    * `条件?表达式1:表达式2` 根据前面条件真只求值表达式1，条件假只求值表达式2
    * 逗号左边表达式在右边表达式前生效，若是赋值操作赋的值是最后一个逗号后表达式的值

## 关键字

* 注：下列字符不是关键字，但有特殊含义
    * C++11用于类： `final` 、 `override`
    * C++20用于模块： `export` 、`import` 、 `module`

### 运算符关键字

| operater       | keyword                    | description      |
| ---------------| -------------------------- | ---------------- |
| `~`  `!`  `!=` | `compl`  `not`    `not_eq` | 位非/逻辑非/不等 |
| `&`  `^`  `\|` | `bitand` `xor`    `bitor`  | 位逻辑           |
| `&&`    `\|\|` | `and`             `or`     | 逻辑             |
| `&=` `^=` `\|=`| `and_eq` `xor_eq` `or_eq`  | 位逻辑运复合赋值 |

### 字符型关键字

* 字符型关键字
    * `char` ：字符型，一般为8位，有无符号取决于编译器，一般是有符号
    * `wchar_t` ：宽字符型(C++)，Windows上是UTF-16，Linux上是UTF-32，所以它被视为缺陷并被移除
        * `wcin` 和 `wcout` 可用于处理wchar_t流
    * `char8_t` ：UTF-8字符型，无符号数(C++20)
    * `char16_t` ：UTF-16字符型(C++11)
        * 与 `\u00F6` 形式的通用字符名匹配
    * `char32_t` ：UTF-32字符型(C++11)
        * 与 `\U0000222B` 形式的通用字符名匹配
<br>

* 字面值
    * 单个字符用 `' '` ，字符串用 `" "` ，字符串默认以 `'\0'` (空字符NUL)结尾
    * `L` 前缀来指示宽字符常量和字符串 `wcha_t`
    * `u8` 前缀来指示UTF-8字符常量和字符串 `char8_t`
    * `u` 前缀来指示UTF-16字符常量和字符串 `char16_t`
    * `U` 前缀来指示UTF-32字符常量和字符串 `char32_t`
    * 原始字符串 `R"(字符串)"` ，特殊字符保留原样，例如换行会保留
        * 允许在 `R"` 和 `(` 中间添加其它字符，例如： `R"+*(字符串)+*"`
<br>

* 常用ASCII码
    | 字符             | NUL | Space | 0   | A   | a   |
    | ---              | --- | ---   | --- | --- | --- |
    | ASCII码(10进制)  | 0   | 32    | 48  | 65  | 97  |
    | ASCII码(16进制)  | 00  | 20    | 30  | 41  | 61  |
<br>

* 转义字符
    | 字符             | 响铃 | 退格 |水平制表 | 换行 |垂直制表 | 换页| 回车 | 双引号 | 单引号 | 问号 | 反斜杠|
    | ---              | ---  | ---  | ---     | ---  | ---     | --- | ---  | ---    | ---    | ---  | ---   |
    | 转义字符         | \a   | \b   | \t      | \n   | \v      | \f  | \r   | \"     | \'     | \?   | \\    |
    | ASCII码(10进制)  | 7    | 8    | 9       | 10   | 11      | 12  | 13   | 34     | 39     | 63   | 92    |
    | ASCII码(16进制)  | 07   | 08   | 09      | 0A   | 0B      | 0C  | 0D   | 22     | 27     | 3F   | 5c    |
<br>

* 泛化转义序列
    * `\n1n2n3` : 八进制数字值代表的字符
    * `\xn1n2`  : 十六进制数字值代表的字符(它由一个反斜线符、一个 x 和一个或者多个十六进制数字组成)
    * 形式是`\x`后紧跟1个或多个十六进制数字，或者`\`后紧跟1个、2个或3个八进制数字，其中数字部分表示字符对应的数值
    * 如果`\`后面跟着的八进制数字超过3个，则只有前3个数字与`\`构成转义序列。相反，`\x`要用到后面跟着的所有数字

### 整型关键字

* 整型关键字
    * `short` ：短整型，一般为16位
    * `int` ：基本整型，一般为32位
    * `long` ：长整型
        * `long` 长整型，32位Windows和Linux为32位，64位Windows为32位，64位Linux为64位
        * `long long` 长长整型一般为64位
<br>

* 数型修饰关键字
    * `signed` ：有符号数，修饰整型和char
        * 有符号整型 `signed` 一般会省略
        * 如果将char当成有符号整形使用，要显示加 `signed`
        * 最高位为符号位：1为负数；0为0或正数
    * `unsigned` ：无符号数，修饰整型和char
<br>

* 数型位要求
    * short至少16位(一般16位)
    * int至少与short一样长(一般32位)
    * long至少32位，且至少与int一样长(32位系统一般32位，64位系统一般为64位)
    * long long至少64位，且至少与long一样长(一般64位)(C++11)
<br>

* 固定位整型(非关键字)
    * 应用使用固定位整型可包含标准库 `#include <stdint.h>`
        * 有符号数: `int8_t` `int16_t` `int32_t` `int64_t`
        * 无符号数: `uint8_t` `uint16_t` `uint32_t` `uint64_t`
    * 驱动使用固定位整型可包含linux头文件 `#include <linux/types.h>`
        * 有符号数: `int8_t`  `int16_t` `int32_t` `int64_t`
        * 有符号数: `s8` `s16` `s32` `s64`
        * 无符号数: `uint8_t` `uint16_t` `uint32_t` `uint64_t`
        * 无符号数: `u8` `u16` `u32` `u64`
<br>

* 数型字面值
    * 默认类型是 `十进制` 的 `int`
    * `0` 前缀表示 `八进制`
    * `0x` 或 `0X` 前缀表示 `十六进制`
    * `0b` 或 `0B` 二进制(C++14)
    * `L` 或 `l` 后缀表示 `long` ，`LL` 或 `ll`后缀表示 `long long`
    * `U` 或 `u` 后缀表示 `unsigned`
    * 十进制或者科学计数法来表示浮点字面值常量，使用科学计数法时，指数用 E 或者 e 表示
    * C++14新增了单引号`'`形式的数字分隔符，数字分隔符不会影响数字的值，仅为了使数值读写更容易

### 布尔型关键字

* 布尔型关键字(C++/C23)
    * `bool` ：布尔类型
    * `true` ：字面值真
    * `false` ：字面值假
<br>

* 布尔值说明
    * 布尔整型是C++的内置类型，C23前不是C的内置类型，C使用布尔整型需要包含标准库 `#include <stdbool.h>`
    * 字面值true和false可以通过提升转换为int类型，true被转换为1，而false被转换为0
    * 任何数字值或指针值都可以被隐式转换为bool值，任何非零值都被转换为true，而零被转换为false
    * `sizeof(bool)` 的值由实现定义，而且不一定是 `1`

### 浮点型关键字

* 浮点型关键字
    * `float` ：单精度浮点型，至少32位，一般为32位有符号，IEEE-754 binary32 格式
    * `double` ：双精度浮点型，少48位，且不少于float，一般为64位有符号，IEEE-754 binary64 格式
        * `long double` ：扩展精度浮点数类型，至少和double一样多，不同平台的实现有差异，可能是64、80、128位

* 定宽浮点数类型(C++23)(非关键字，stdfloat中定义)
    | 类型名称   | 字面量后缀 | C 语言类型 | 符号位数 | 指数位数 | 尾数位数 |
    | ---------  | ---------- | ---------- | :------: | :------: | :------: |
    | float16_t  | f16 /F16   | _Float16   |    1     |     5    |    10    |
    | float32_t  | f32 /F32   | _Float32   |    1     |     8    |    23    |
    | float64_t  | f64 /F64   | _Float64   |    1     |     11   |    52    |
    | float128_t | f128/F128  | _Float128  |    1     |     15   |    112   |
    | bfloat16_t | bf16/BF16  | 无         |    1     |     8    |    7     |

* 浮点数表示方法说明
    * 从最高有效位(MSB)开始，组成如下：
        * 符号位S固定为1位，0表示正数，1表示负数
        * 指数位E表示2的N次方，`N = E - ((1 << (Ebits - 1)) - 1)`
            * 例如：double的N为 `N = E - ((1 << 10) - 1) = E - 1023`
        * 尾数位M决定底数的值(高位可能有额外的1)，即 `D = M` 或 `D = M + (1 << Mbits)`
    * 根据指数和尾数的不同，有下面5种类型：
        * E和M都是0： 正零 `0.0` 或 负零 `-0.0`
        * E是最大值，M不是0：正无穷 `INFINITY` 或 负无穷 `-INFINITY`
        * E是最大值，M是0：非数 `NaN`
        * E为0，M不为0：非规格化数 `V = ((-1) ^ S) * M * (2 ^ N)`
        * E不为0，M不为0：规格化数 `V = ((-1) ^ S) * (M + (1 << Mbits)) * (2 ^ N)`
    * 浮点数表示的值用十进制表示是一个范围，转换为十进制的原则是约数位 `约到最近数，等距取偶数，约成最短数`
        * 约数位可能不只一位，取决于相邻数的差值
        * 例如double能表示的十进制精度为17位 (1<<52最大能表示的十进制数是16位，再加1位)
<br>

* 浮点型字面值
    * 标准小数点表示法 `12.34` `8.0`
    * 科学计数表示法 `3.45E6` `7E5` `1.68e4` (E表示10的指数)
    * 默认类型是 `double`
    * `f` 或 `F` 后缀表示 `float`
    * `l` 或 `L` 后缀表示 `long double`

### 复合类型关键字

* 复合类型
    * `enum` ：枚举(一系列整形值)
        * C++11新增有作用域枚举 `enum struct` 或 `enum class` ，例如 `enum class new_enum : unsigned char { };`
            * 不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较，也不能对不同的枚举类型的枚举值进行比较
    * `union` ：联合(多个变量复用同一内存空间)
    * `struct` ：结构体，C++中定义为默认公有类
    * `class` ：默认私有类(C++)
<br>

* 无类型
    * `void` ：无参数或无返回值
<br>

* 指针
    * `nullptr` ：空指针常量，是std::nullptr_t类型的纯右值，不能转换为整数(C++11/C23)
        * C中空指针使用 `NULL` (C23前)，可能被编译器定义为 `0` 或 `(void *)0`
        * C++加入 `nullptr` 的原因是防止函数重载出错
        * `nullptr` 能够隐式的转换为任何指针或成员指针的类型， 也能和他们进行相等或者不等的比较
    * `this` : 类指针，类的非静态成员函数默认传入当前类指针(C++)
        * `void foo(this X const& self, int i);` 显示传入类指针，等效 `void foo(int i) const &;` (C++23)

### 类型转换关键字

* `castname<type>(val)` ，castname关键字：(C++)
    * `static_cast`  : 编译时检查的类型转换(最常用)
        * 编译器隐式执行的任何类型转换都可以由此方式显式完成
        * 从一个较大的算术类型强制转换为一个较小类型的赋值
        * `void *` 指针强制转换为原来的指针，把其他指针转换为 `void *` 指针
        * 整数和枚举间的转换
    * `dynamic_cast` : 运行时检查的类型转换，需要检查可能失败
        * **可能会转换失败，需要检查返回值是否为空**
        * 用于类继承层次间的指针或引用转换
        * 主要用于执行安全的向下转型(safe downcasting)(即基类指针或引用转换为其派生类的)
        * 向上转型(即派生类指针或引用转换为其基类的)本身就是安全的，无需使用特定方式进行转换
    * `reinterpret_cast`: 不检查的类型转换，非关联类型
        * 将某类型的内存中存储的数据解释为另一种不同的类型
        * 强制非 `void *` 的指针间转换
        * 把一个指针转换成一个整数，也可以把一个整数转换成一个指针
    * `const_cast` : const转换
        * 将 `const` / `volatile` 对象转换为相应的普通类型
        * 只能用于底层 const：指向常量的指针、指向常量的引用、常量对象去除const
        * 一般用于重载函数上下文中
        * 如果对象本身是常量使用 `const_cast` 将产生未定义的行为
<br>

* shared_ptr的强制转换(非关键字)(C++11)
    * `std::dynamic_pointer_cast` (推荐)
        * 基于运行时类型检查(RTTI)，验证转换是否安全
        * 成功返回派生类shared_ptr，与原指针共享所有权(引用计数+1)
        * 失败返回空指针，无未定义行为
        * unique_ptr不支持直接基类到派生类转换，需要先转换为shared_ptr再转换为派生类
    * `std::static_pointer_cast` (谨慎使用)
        * 编译时转换，无运行时检查，若实际对象非派生类，导致未定义行为(如内存越界)
<br>

* `(type)val` ：**C只能用这种方式**(C/C++)
    * C风格类型转换，例如 `long a = 10.01; int b = (int)a;`
* `type(val)` ：不建议用这种方式(C++)
    * 函数风格类型转换，例如 `long a = 10.01; int b = int(a);`

### 附：数值转换

* 转换场景
    * 将一种算术类型的值赋给另一种算术类型的变量时
    * 表达式中包含不同的类型时
    * 将参数传递给函数时
        * 传递参数时的类型转换通常由C++函数原型控制，然而，也可以取消原型对参数传递的控制，此时
            * char和short类型(signed和unsigned)应用整型提升
            * float参数提升为double
<br>

* 潜在的数值转换问题
    * 将较大的浮点类型转换为较小的浮点类型，如将double转换为float
        * 精度(有效数位)降低，值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的
    * 将浮点类型转换为整型
        * 小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的
    * 将较大的整型转换为较小的整型，如将long转换为short
        * 高位部分被截断，原来的值可能超出目标类型的取值范围，通常只复制低边的字节
    * 负数赋值给正数
        * 把负值赋给unsigned对象是完全合法的，其结果是该负数对该类型的取值求模后的值
        * 例如：把-1赋给8位的unsigned char，那么结果是255， 因为255是-1对256求模后的值
<br>

* 表达式中的转换
    1. 如果有一个操作数的类型是long double，则将另一个操作数转换为long double
    2. 否则，如果有一个操作数的类型是double，则将另一个操作数转换为double
    3. 否则，如果有一个操作数的类型是float，则将另一个操作数转换为float
    4. 否则，说明操作数都是整型，因此执行整型提升
        * 比int小的量自动提升到int，将bool、char、unsigned char、signed char和short值转换为int
        * 如果short比int短，则unsigned short类型将被转换为int；如果两种类型的长度相同，则unsigned short类型将被转换为unsigned int
        * 有一个操作数为long，表达式的值提升为long
    5. 在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低，则转换为级别高的类型
    6. 如果一个操作数为有符号的，另一个操作数为无符号的，且无符号操作数的级别比有符号操作数高，则将有符号操作数转换为无符号操作数所属的类型
    7. 否则，如果有符号类型可表示无符号类型的所有可能取值，则将无符号操作数转换为有符号操作数所属的类型
    8. 否则，将两个操作数都转换为有符号类型的无符号版本

### 附：格式化输出

* 格式: `%[flags][width][.perc]type`
<br>

* 输出类型
    * 整型
        * `%d` 十进制int | `%x` 十六进制int | `%o` 八进制int
        * `%u` 无符号int
        * `%hd` short | `%ld` long | `%lld` long long
        * `%hhu` unsigned char | `%hu` unsigned short | `%lu` unsigned long | `%llu` unsigned long long
    * 浮点型
        * `%f` float/double | `%lf` long double
        * `%e`或`%E` 十进制指数 | `%a`或`%A` 十六进制指数
        * `%g`或`%G` 输出 `%f` 与 `%e` / `%E` 中较短者
    * 其它
        * `%c`字符
        * `%s`字符串
        * `%p`指针
<br>

* 输出格式
    * 输出宽度：宽度也可用于数字和字符串，大于宽度原样输出，否则如下规则
        * `%nd`   n位宽度，右对齐，左边填充空格(宽度也可用于其它类型，例如 `%16s` `%8d`)
        * `%0nd`  n位宽度，右对齐，左边填充0
        * `%-nd`  n位宽度，左对齐，右边填充空格
        * `%n.mf` n位宽度(小数点也算，n可省略)，其中m位小数(不足m位补零)
    * 其它格式
        * `%+d`   在有符号数字前增加符号 + 或 -
        * `%#x`或`%#X` 十六进制前缀0x或0X  `%#o`八进制前缀0
        * `%*s`用于读取表示读取后丢弃，用于输出表示动态长度，例如 `scanf("%d%*s",&a)` `printf("%*s", 10, s)`

### 流程控制关键字

* 分支
    * `if` ：构成if...else选择结构
    * `else` ：构成if...else选择结构
    * `switch` ：构成switch选择结构
    * `case` ：switch语句中选择项
    * `default` ：switch语句中的默认选择项
        * C++11还可用于令编译器为某个类生成默认特殊成员函数
        * C++20还可令编译器为某个类生成默认比较
<br>

* 循环
    * `do` ：构成do...while循环语句
    * `while` ：构成do...while或while循环结构
    * `for` ：构成for循环语句
<br>

* 跳转
    * `continue` ：中断本次循环，并继续下一次循环
    * `break` ：中断跳出最内层循环或case语句
    * `goto` ：构成goto转移结构
    * `return` ：用于返回函数的返回值
<br>

### 异常关键字

* `try` ：运行可能跑异常的代码
    * `try { 运行可能抛出异常的代码 }` ： 通常try块
    * `类名 try : 成员初始化表 {  }` ： 构造函数try块
* `catch` ：捕获异常进行处理
    * `catch ( 属性(可选) 类型说明符序列 声明符) { 异常处理 }` ：捕获特定异常
        * 通过变量名直接访问异常对象的成员，例如 `const std::exception& e`
    * `catch ( 属性(可选) 类型说明符序列 抽象声明符(可选)) { 异常处理 }` ：捕获特定异常
        * 仅匹配异常类型，无法获取具体信息，例如 `std::out_of_range`
    * `catch (...) { 异常处理 }` ：捕获所有异常
* `throw` ：抛出异常
    * `throw` ：重新抛出当前正在处理的异常
    * `throw 表达式`：抛出新的异常
* `noexcept` ：要求函数不抛出任何异常(C++11)
    * `noexcept(表达式)` ：进行编译时检查，若表达式声明为不抛出任何异常则返回 `true`
    * `noexcept` `noexcept(true)` ：声明函数不会抛出异常
    * `noexcept(false)` ：声明函数可能会抛出异常
    * `noexcept` 说明不是函数类型的一部分，添加规定如下：
        * 在声明函数、变量、函数类型的非静态数据成员、函数指针、函数引用或成员函数指针时，
        * 在以上这些声明中声明类型为函数指针或函数引用的形参或返回类型时作为lambda声明符或顶层函数声明符的一部分
        * 不能在 typedef 或类型别名声明中出现

```cxx
try {
    f();
} catch (const std::overflow_error& e) {
    // 如果 f() 抛出 std::overflow_error 就会执行它(“相同类型”规则)
} catch (const std::runtime_error& e) {
    // 如果 f() 抛出 std::underflow_error 就会执行它(“基类”规则)
} catch (const std::exception& e) {
    // 如果 f() 抛出 std::logic_error 就会执行它(“基类”规则)
} catch (...) {
    // 如果 f() 抛出 std::string 或 int 或任何其他无关类型就会执行它
}
```

```cxx
void f() noexcept; // 函数 f() 不会抛出
void (*fp)() noexcept(false); // fp 指向可能会抛出的函数
```

### 类型修饰关键字

* `auto` ：局部变量(一般省略不写auto)(C++还有类型推导含义，见后续章节)
* `thread_local` (C++11/C23) / _Thread_local(C11): 线程局部变量
* `register` : 寄存器局部变量(C++17弃用)
* `static` ：静态变量或函数
    * 用于函数定义或代码块外变量声明时，函数或变量只能在声明他们的源文件中访问
    * 用于代码块内变量声明时，将变量类型由栈周期修改为静态周期，只在第一次访问时初始化
    * C++ `static` 修饰的类函数为静态成员函数，类实例共享一份实现，访问方式为 `类名::函数名()`
    * C++ `static` 修饰的类变量为静态成员变量，类实例共享一份实现，访问方式为 `类名::变量名`
    * 静态成员函数可在类中定义，静态成员变量需要在类外定义， `static` 只在类声明中加，类外定义无需加
* `extern` ：具有外部链接的静态存储期说明符，或声明引用外部文件中的全局变量
    * C++11还可用于模板显式实例化声明
<br>

* `restrict` ：唯一指针(C99)，C++中由编译器实现可能是 `__restrict`
    ```cxx
    // add1可能返回17或18，因为a b可能指向同一个对象
    int add1(int *a, int *b) { *a = 8; *b = 9; return *a + *b; }
    // add2一定返回17，restrict表明a b是不同对象的指针
    int add2(int *restrict a, int *restrict b) { *a = 8; *b = 9; return *a + *b; }
    ```
* `volatile` ：执行中可被隐含地改变的变量，访问volatile声明的变量时候，总是重新从它所在的内存读取或写入
<br>

* `_Atomic` ：原子类型修饰(C11)
    * `_Atomic(类型名)` ：用作类型说明符，指代新的原子类型
        * C++ 使用 `std::atomic<类型名>`
    * `_Atomic 类型名` ：用作类型限定符，指代类型名的原子版本
    * 头文件 `<stdatomic.h>` 定义了许多便利的别名，从 `atomic_bool` 到 `atomic_uintmax_t`

### 对齐修饰关键字

* `alignas` (C++11/C23) / `_Alignas(C11)` ：指定类型或对象的对齐要求
    * 作用：强制变量或类型按特定字节边界对齐，优化内存访问效率
    * 约束：
        * 对齐表达式必须是求值为2的x次方
        * 不可用于函数形参、catch子句的异常形参、位域成员或register变量
    ```cxx
    struct alignas(N) MyStruct { ... }; // 类成员按N字节对齐
    struct alignas(void *) MyStruct { ... }; // 类成员按 `void *` 对齐字节对齐
    ```
* `alignof (C++11/C23)` / `_Alignof(C11)` ：查询对齐要求
    * 作用：返回类型或对象的对齐字节数(编译期常量)
    ```cxx
    size_t alignment = alignof(Type);
    ```
注：C11中头文件 `<stdalign.h>` 中将 alignas/alignof 定义为展开成该关键词的预处理器宏
<br>

* `#pragma pack` 对齐(C++/C99)

    | 语法                    | 作用                                              |
    | ----------------------  | ------------------------------------------------- |
    | `#pragma pack(n)`       | 设置后续结构体的最大对齐边界为n字节(n为2的幂)     |
    | `#pragma pack()`        | 恢复编译器默认对齐方式(通常为4/8字节或平台默认值) |
    | `#pragma pack(push)`    | 保存当前对齐设置到内部编译器栈                    |
    | `#pragma pack(push, n)` | 保存当前对齐设置并同时设置新对齐为 `n` 字节       |
    | `#pragma pack(pop)`     | 恢复最近一次push保存的对齐设置(若栈空则恢复默认)  |

    ```c
    #pragma pack(push, 1)   // 保存当前设置并设为 1 字节对齐
    struct NetworkPacket {
        char header;
        int payload;
        char *data;
    };
    #pragma pack(pop)       // 恢复先前设置
    ```

* GCC/CLANG 对单个结构体对齐的扩展
    * `__attribute__((aligned(n)))` ：指定结构体字节对齐数，必须是2的N次方
    * `__attribute__((packed))`     ：指定结构体字节紧密分配，即对齐到1字节

    ```c
    // GCC/CLANG 专用
    struct NetworkPacket {
        char header;
        int payload;
        char *data;
    } __attribute__((packed));
    ```

### const修饰关键字

* `const` ：通用只读语义(C/C++)
    * 核心语义：声明变量、函数参数或成员函数为“只读”，但值可在运行时确定
    * 典型场景：
        * 在全局作用域声明的 const 变量是定义该对象的文件的局部变量，通过指定 const 变更为 extern才能在其他文件访问
        * 修饰变量，运行时要初始化后，后续不可再修改，例如： `const int size = get_size();`
        * 修饰类成员函数，保证函数不修改类对象状态，例如： `int get() const;`
<br>

* `constexpr` ：编译期求值(C++11/C23)
    * 核心语义：要求变量或函数返回值在编译期可计算，支持编译期优化
    * 典型场景：
        * 可运行时调用，可用于替代宏定义，提供类型安全
        * constexpr函数允许简单的分支，循环语句(C++14)
        * 变量：必须用常量表达式初始化，例如：`constexpr int N = 42;` ，后续不能修改变量
        * 函数：可在编译期或运行时调用，例如： `constexpr int fac(int n) { ... }`
        * `if constexpr (条件) { 语句块 }` ：让代码在编译时就完成分支判断(C++17)
<br>

* `consteval` ：强制编译期执行的函数(C++20)
    * 核心语义：修饰的函数必须在编译期求值，否则编译失败，运行时调用非法
    * 典型场景：
        * 编译期静态检查(如参数验证)
        * 生成元数据(如字符串哈希、ID映射表)
  ```cxx
  consteval int square(int x) { return x * x; } // 必须编译期调用
  constexpr int a = square(5); // ✅ 编译期求值
  int b = square(10);          // ❌ 错误：运行时调用非法
  ```
<br>

* `constinit` ：编译期初始化保证(C++20)
    * 核心语义：确保静态存储期变量(全局/静态变量)在编译期初始化，避免“静态初始化顺序问题”(SIOF)
    * 典型场景：
        * 仅适用于静态存储周期对象，多线程环境下避免静态初始化竞争，替代动态初始化
        * 替代动态初始化(如constinit std::atomic<int> counter = 0;)。
        * 初始化表达式必须是常量表达式，后续变量可修改，例如：`constinit int id = 42;` ，后续可修改id

### 类型别名和推导关键字

* `sizeof` ：获取对象字节大小(C/C++)
    * 对引用类型执行 `sizeof` 运算得到被引用对象所占空间的大小
    * `sizeof(expr)` 返回表达式结果类型大小，但并不实际计算表达式，例如 `sizeof(a=b+1)` 没有向a赋值
    * `sizeof(数组)` 返回数组占用的字节大小 `num * sizeof(p[0])`，即得到数组元素个数 `sizeof(p)/sizeof(p[0])`
    * C++对string和vector对象 `sizeof` 操作不是返回对象中的元素占据了多少空间，而是该类型空间固定部分的大小
<br>

* `typedef 类型原名 类型新名;` (C/C++)
    * 传统方法定义类型别名
* `using 类型新名=类型原名;` (C++11)
    * 定义类型别名，**可为模板定义别名**，而 `typedef` 不可以
    * 类型别名通常被用于以下三种目的：
        * 为了隐藏特定类型的实现，强调使用类型的目的
        * 简化复杂的类型定义，使其更易理解
        * 允许一种类型用于多个目的，同时使得每次使用该类型的目的明确
<br>

* `auto var = expr;` 类型推导(C++11)
    * 让编译器自动分析表达式所属的类型， `auto` 定义的变量必须有初始值
    * 编译器推断出来的 `auto` 类型有时和初始值的类型并不完全一样
        * 一般会**忽略顶层const**，如果希望推断出的 `auto` 类型是一个顶层 `const` ，需要显式指定`const auto`
        * 表达式类型一定不会是引用类型，此时需要显式指定 `auto&`
        * auto不能用于推导数组类型，例如 `auto arr[100] = other_arr;` 是错误的
        * auto可用于函数传参类型(C++14)，例如 `int add(auto x, auto y) { return a + b; }`
    * 常用场景：
        * 对于变量，指定要从其初始化表达式自动推导出其类型(C++11)
        * 对于函数，指定要从其 return 语句推导出其返回类型(C++14)
        * 对于泛型lambda表达式允许使用auto作为参数类型，从而自动推导lambda参数的类型(C++14)
* `auto [var1, var2, ...] = <pair, tuple, struct, or array expression>;` ：结构化绑定(Structured Bindings) (C++17)
        * 声明多个变量，并分别绑定到 `键值对/元组/结构体/数组` 的成员
        * `auto 部分` ：可以是 auto , const auto , const auto& 和 auto&&
        * `[var1, var2, ...]` 表示一个变量列表，其变量数量必须匹配表达式所对应的结构
        * 如果绑定的是结构体或数组：结构体的所有成员都必须是非静态成员，每个成员以基础类定义；数组必须是定长数组
<br>

* `decltype(expr) var;` 类型推导(C++11)
    * 返回表达式(函数返回，类成员)的类型(包括顶层const和引用在内)
    * 推导的的类型就和expr一致：
        * expr是一个不被括号包围的表达式
        * expr是一个类成员访问表达式
        * expr是一个单独的变量
    * 推导的类型就和函数返回值的类型一致
        * expr是函数调用(函数不能是void函数)
    * 推导的类型就是expr类型的引用
        * expr是一个左值，例如： `decltype(a=b+c)` ，
        * expr是一个被括号包围的表达式，例如： `decltype((expr))`
<br>

* `typeof` / `typeof_unqual` : typeof运算符，编译时动态推导表达式或变量的类型(C23)
    * `typeof` 用于获取表达式或变量的完整类型(包括限定符如 `const` `volatile` `restrict` 和原子类型等)
    * `typeof_unqual` 用于获取表达式或变量的移除限定符类型
    * 运算符不能被用于位域成员
    * `typeof` 还不是关键字时，就是GCC/CLANG编译器的私有扩展
<br>

* `typeid` ：查询对象的实际类型(C++ RTTI)
    * `typeid(var or expr).name()` ：类型名称获取，返回编译器相关的类型名称字符串
    * `typeid(a) == typeid(b)` ：类型比较，判断两对象类型是否相同
    * 注意点
        * 若基类无虚函数，`typeid(*ptr)` 返回基类类型而非实际派生类型
        * 解引用空指针时，typeid 抛出 `std::bad_typeid` 异常

### 名称空间关键字(C++)

* `namespace` ：定义名称空间
    * 定义可以嵌套
        ```cxx
        namespace 名称空间名{
            声明;
            函数等定义{}
        };
        ```
    * `namespace 新名称空间名=旧名称空间名` ：定义别名
<br>

* `using` ：使用名称空间
    * `using 名称空间名::内部成员名;` ：使用单个名
    * `using namespace 名称空间名;` ：使用名称空间全部

### 类关键字(C++)

* 访问权限或继承方式关键字
    * `public`    ：公有成员，无访问限制
    * `protected` ：保护成员，只能在本类以及其继承类和友元中访问
    * `private`   ：私有成员，无访问限制，只能在本类以及友元中访问
    * `friend`    ：友元，可以访问与其有friend关系的类中的private/protected成员

* 特殊成员函数控制关键字(默认构造函数、复制构造函数、移动构造函数、复制运算符函数、移动运算符函数)
    * `default` ：生成默认特殊成员函数(C++11)
    * `delete` ：删除默认特殊成员函数(C++11)
    * `operator` ：操作符重载

* 修饰关键字
    * `explicit` ：禁止编译器对构造函数进行隐式类型转换，避免意外转换(C++11之前只支持单参数)
    * `const` ：表明是常量成员函数，即 `this` 指向的当前对象不可在此成员函数中修改
    * `mutable` ：表明允许在常量成员函数中修改被修饰的 `mutable` 成员变量
    * `virtual` ：声明虚函数，支持运行时多态(派生类可重写)
    * `override` ：显式标记派生类中对基类虚函数的重写，编译器检查签名一致性
    * `inline` : 内联函数(C99/C++)
        * 在类内部定义成员函数，默认是 `inline` 型
        * 在类外部定义的成员函数，也可以在声明时显式地加上 `inline`
        * 定义的普通函数，也可以在定义时显式地加上 `inline`
    * `final` ：终止继承/重写(C++11)

### 模板关键字(C++)

* 模板定义关键字
    * `template` ：定义模板
    * `typename` ：模板中把一个特殊的名字解释成一个类型
    ```cxx
    template<class T>
    constexpr T pi = T(3.1415926535897932385L); // 变量模板，定义一族变量或静态数据成员(C++14)

    template<class T>
    T circular_area(T r) { // 函数模板
        return pi<T> * r * r; // pi<T> 是变量模板实例化
    }
    ```

* 概念约束关键字(C++20)
    * `concept`  ：用于定义模板参数的编译期约束条件，用于检查类型是否满足特定行为或属性
    * `requires` ：在模板中直接启用约束

    ```cxx
    // 定义约束
    template<typename T>
    concept Addable = requires(T a, T b) {
        { a + b } -> std::convertible_to<T>;  // 要求支持加法且结果可转为T
    };

    // 应用约束
    template<typename T>
    requires Addable<T>  // 应用Addable约束
    T add(T a, T b) { return a + b; }
    ```

* 外部模板(C++11)
    * 传统 C++中， 模板只有在使用时才会被编译器实例化，产生重复实例化
    * C++11引入了外部模板，可以显式的通知编译器何时进行模板的实例化
    ```cxx
    template class std::vector<bool>; // 强行实例化
    extern template class std::vector<double>; // 不实例化
    ```

* `_Generic` ：泛型选择(Generic selection)(C11)
    * `_Generic ((控制参数), 关联列表, ...)(函数传参)`
        * `_Generic()` 是泛型选择关键字
        * 控制参数用小括号 `()` 包围，表示控制哪个参数
        * 关联列表项使用冒号 `:` 隔开控制参数的类型或值
        * 多个关联列表项使用逗号 `,` 分隔
        * 最后是小括号 `()` 包围函数传参

    ```c
    /* https://gitee.com/lengjingzju/json 中的例子 */
    #define pjson_array_append(array, value, mem)  _Generic((value), \
    bool            : pjson_add_bool_to_array                      , \
    int32_t         : pjson_add_int_to_array                       , \
    uint32_t        : pjson_add_hex_to_array                       , \
    int64_t         : pjson_add_lint_to_array                      , \
    uint64_t        : pjson_add_lhex_to_array                      , \
    double          : pjson_add_double_to_array                    , \
    json_string_t*  : pjson_add_string_to_array)                     \
    (array, value, mem)
    ```

### 协程关键字(C++20)

* `co_await` ：挂起协程，等待异步操作
    * 作用：
        * 暂停当前协程的执行，将控制权返回给调用者或调度器。
        * 等待异步操作(如 I/O、网络请求)完成，完成后恢复协程并获取结果。
   * 核心机制：
        * 依赖awaitable对象(例如 std::suspend_always)或自定义awaiter
            * 需实现 `await_ready` 、 `await_suspend` 、 `await_resume` 3个方法
            * `若 await_ready()` 返回 `false`，协程挂起；否则直接继续执行

* `co_yield` ：生成值流，暂停并返回值
    * 作用：
        * 向调用方返回一个值，同时挂起协程，后续可恢复执行
        * 适用于生成器模式(Generator)，按需生成序列
    * 核心机制：
        * 通过 `promise_type::yield_value()` 保存返回值，并挂起协程
        * 协程恢复时从 `co_yield` 之后继续执行

* ` co_return` ：结束协程并返回值
    * 作用：
        * 终止协程的执行，返回最终结果
        * 通知调用方协程已结束，结果通过 `promise_type::return_value()` 存储
        * `co_return` 不能直接返回值给调用者，而是通过协程的返回对象获取结果

```cxx
generator<int> asyncStream() {
    for (int i = 0; ; ++i) {
        auto data = co_await fetchAsyncData(); // 等待数据
        co_yield data;                        // 生成数据
        if (i > 100) co_return;               // 结束协程
    }
}
```

### 模块关键字(C++20)

* `module` ：模块定义
* `export` ：模块导出
* `import` ：模块导入

### 其他关键字(C++)

* `asm` ：嵌入汇编代码，C中由编译器实现可能是 `__asm__`
* `new` ：动态申请对象
* `delete` ：释放动态申请的对象，C++11还可用于类中删除特殊成员函数
* `static_assert(条件)` (C++11/C23) / `_Static_assert` (C11) ：静态断言检查，条件不满足时编译失败
    * `assert(条件)` ，运行时断言， 定义在 `assert.h` 头文件，条件不满足时默认崩溃(定义了名为 `NDEBUG` 的宏，那么断言会禁用)

## 变量概念

### 定义和声明

* 格式：`可选前置修饰符 基础数据类型 可选声明运算符 可选后置函数修饰符 可选初始化表达式或函数体;`
    * 每个定义都是以**类型说明符**开始，后面紧跟着以**逗号**分开的含有一个或多个说明符的列表，**分号**结束定义
    * 前置修饰符：指定所声明对象的某些非类型属性
        * C/C++: `auto` `static` `extern` `const`
        * C++: `constexpr` `constval` `constinit`
    * 基础数据类型必须指定(C没有指定会被隐式声明为int，C23会报错)
    * 声明符：由一个标识符和可选的若干声明运算符组成
        * 标识符
            * 自定义标识符必须是字母开头，由字母、数字、下划线构成，并且不能与保留字同名
            * 可以声明为多个名字，中间用逗号隔开
            * C++ 标准还保留了一组标识符用于标准库：2个连续的下划线，以下划线开头后面紧跟一个大写字母
            * 有些标识符(函数外定义的标识符)不能以下划线开头
            * 标识符区分大小写，建议宏全大写，建议多个单词使用下划线隔开(C风格)或不用下划线而是首字母大写(C++风格)
        * 声明运算符
            * C/C++: `数组[]`  `*指针`  `*const 常量指针` `*volatile 指针`  `函数()`
            * C++: `&左值引用` `&&右值引用`
            * 注：后缀比前缀绑定优先，声明运算符只能作用一个标识，不能作用于同一声明的共有标识
                * 例如 `int *a, b;` 中b不是指针，都要定义为指针应该是 `int *a, *b;`
<br>

* 定义和声明区别
    * 变量的定义用于为变量分配存储空间，还可以为变量指定初始值
    * 声明用于向程序表明变量的类型和名字，定义也是声明：当定义变量时我们声明了它的类型和名字
    * 程序中变量可以声明多次，但只能定义一次，而且在使用变量之前必须定义或声明变量
    * 同一个作用域内，一个变量名只能有一个声明，变量必须先声明再使用，除函数和名称空间外，其他声明必须以分号结束
    * 可以通过使用 extern 关键字声明变量名而不定义它，如果声明有初始化式，那么它可被当作是定义
    * 通常把一个对象定义在它首次使用的地方是一个很好的办法
    * 名字从其声明点开始直到其声明所在的作用域结束处都是可见的
    * C/C++中，一个块内声明的名字可以遮蔽其外围块内声明的同名，或全局的同名
        * C++中，代码块内部可以在被遮蔽的全局名字前加作用域解析符::引用
<br>

* 当一个定义中定义了两个以上变量的时候，每个变量都可能有自己的初始化式。
    * 对象的名字立即变成可见，所以可以用同一个定义中前面已定义变量的值初始化后面的变量
    * 已初始化变量和未初始化变量可以在同一个定义中定义，两种形式的初始化文法可以相互混合
    * 内置类型变量是否自动初始化取决于变量定义的位置
        * 在函数体外定义的变量都初始化成 0，在函数体里定义的内置类型变量不进行自动初始化
        * 建议每个内置类型的对象都要初始化，除非你确定忽略初始化式不会带来风险

### 初始化

* 复制初始化：`变量类型 变量名=值;`      // 等于号 C/C++
* 直接初始化：`变量类型 变量名(值);`     // 小括号 C++
* 列表初始化：`变量类型 变量名={值};`    // 等于花括号 C++11，拷贝初始化
* 列表初始化：`变量类型 变量名{值};`     // 花括号 C++11，直接初始化
    * 初始化指创建变量并给它赋初始值，而赋值则是移除对象的当前值并用新值代替
    * C++ 支持两种初始化变量的形式：复制初始化和直接初始化
        * 复制初始化语法用等号`=`，直接初始化则是把初始化式放在小括号`()`中，直接初始化语法更灵活且效率更高
        * 对内置类型来说，复制初始化和直接初始化几乎没有差别
        * 对类类型的对象来说，有些初始化仅能用直接初始化完成。有多个初始化式时不能使用复制初始化
    * C++11加入了列表初始化，`直接用花括号括起来的值` 或 `=花括号括起来的值`
        * 若使用列表初始化且初始值信息有丢失风险(窄化转换)，编译器会报错
            * 窄化转换：大整型到小整型，大浮点型到小浮点型，浮点型到整型，整型到浮点型
        * 列表初始化列表中可以是表达式，例如 `int *p {new int[10]}`
        * 空的初始化列表`{}` 表示使用默认值进行初始化，例如 `char str[100]{}`
        * 使用 `auto` 关键字推断类型不要用列表初始化，否则最好使用列表初始化
<br>

* 注意点
    * 初始化不等于赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值移除，再用一个新值来替代
    * 若没有初始化，全局的、名称空间的和局部静态的对象(统称为静态对象)都被初始化为适当类型的0
    * 表示一个指针没有指向任何对象，C中用宏 `NULL` (C23前)，C++用字面量 `nullptr` (C++11/C23)
    * C++自定义类型有自定义的默认初始化方式，C不能给结构体成员或函数传参设默认值
    * 若没有初始化，局部对象(自动对象)和在自由存储区建立的对象(动态对象或栈对象)将不会用默认值初始化
    * **没有类型为void的对象**，void表示函数没有返回值，或传参为空，与指针联合使用时 `void *` 表示指向不明对象
<br>

* 初始化列表构造函数(C++11)
    * 普通数组、 POD(Plain Old Data，即没有构造、析构和虚函数的类或结构体)类型都可以使用初始化列表 `{}` 进行初始化
    * 对于类对象的初始化，使用初始化列表 `{}` 进行初始化，需要定义使用 `std::initializer_list` 为参数的构造函数
    ```cxx
    #include <initializer_list>
    #include <vector>
    class MyList {
    public:
        std::vector<int> vec;
        MyList(std::initializer_list<int> list) {
            for (std::initializer_list<int>::iterator it = list.begin(); it != list.end(); ++it)
                vec.push_back(*it);
        }
    };
    ```

### 作用域、链接属性、存储类型

| 变量类型 | 声明位置       | 内存存储 | 作用域                     | 若声明为static |
| ---      | ---            | ---      | ---                        | --- |
| 全局变量 | 所有代码块之外 | 静态内存 | 声明处到文件尾             | 不允许从其他源文件引用 |
| 局部变量 | 代码块起始处   | 栈       | 声明点开始到整个代码块尾部 | 将变量类型由auto修改为static |
| 形式参数 | 函数头部       | 栈       | 整个函数                   | 不允许 |

* 链接属性
    * 外部链接external  : 几个源文件该标识符的声明指向同一实体，关键字 `extern`
    * 内部链接internal  : 同一源文件该标识符的声明指向同一实体，不同源文件该标识符的声明指向不同实体
        * typedef、inline、static、const和无名的名字空间内部具有内部链接
    * 无链接            : 局部变量链接器不可见
<br>

* 存储类型
    * 自动对象auto          : 自动存储，存储于栈中，超出作用域范围即销毁(例如：代码块内定义的变量离开代码块销毁)，每次调用都要重新创建
        * 在函数内部定义的常规变量使用自动存储空间，被称为自动变量
    * 静态对象static        : 静态存储，存储于静态内存中，代码块外，程序运行之前创建，只初始化一次(执行默认列表初始化，一般是初始化为0)，整个程序运行过程中存在
        * 使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static
    * 自由存储对象free-store : 动态存储，C++使用 `new/delete` 控制生命周期，C使用 `malloc/free` 族标准库函数
        * new 可能抛出异常，可以使用无异常版本，例如 `int p = new(nothrow) int[n]{};`，此时无法分配到内存时返回 `nullptr` 而不是抛出异常
    * 临时对象temporary     : 生命周期由用法决定，如果绑定到const引用上，它的周期就是引用的周期，否则和它所处的完整表达式一致
    * 线程局部对象thread-local: 生命周期就是线程的周期
<br>

* 作用域：作用域可嵌套，例如，在全局作用域中声明的名字在函数作用域和语句作用域中都可以访问
    * 局部作用域(local scope)           : 在函数或lambda表达式内定义(即一对花括号里)，作用域从声明处开始，到声明语句所在的块结束为止
    * 语句作用域(statement scope)(C++)  : 在for、while、for 和if语句的小括号中`()`定义，作用域从声明处开始，到语句结束为止
    * 函数作用域(function scope)        : 即函数形参，作用域从声明处开始，到函数体结束为止
    * 类作用域(class scope)(C++)        : 在类中定义的成员，成员名字整个类可见
    * 命名空间作用域(namespace scope)(C++) : 在命名空间中定义，作用域从声明处开始，到名字空间结束为止
        * 内联命名空间 : 可以在父命名空间中定义内联的子命名空间，内联的子命名空间可以把其包含的名字导入到父命名空间中，从而在父命名空间中可以直接访问子命名空间中定义的名字，而不用通过域限定符Child::name的形式来访
    * 全局作用域(global scope)          : 名字定义在任何其他作用域外，作用域从声明处开始，到名字空间结束为止

## 语句

* 声明语句：定义函数中使用的变量的名称和类型
* 赋值语句：使用赋值运算符(=)给变量赋值
* 消息语句：将消息发送给对象，激发某种行动
* 函数调用：执行函数，被调用的函数执行完毕后，程序返回到函数调用语句后面的语句
* 函数原型：声明函数的返回类型、函数接受的参数数量和类型
* 返回语句：将一个值从被调用的函数那里返回到调用函数中
* 空语句  ：只有一个分号 `;`

### 代码块

```cxx
{
    statement1;
    statement2;
    statement3;
    ...
}
```

* 注意：代码块只有一条语句，可以省略 `{ }`

### 分支

* if-else语句
    * 若没有 `{ }` ，else总是和最近的一个if匹配
    * C++17可以在 `if` 中定义变量 `if (定义变量; expression)`
    ```cxx
    if (expression) {
        statement;
        ...
    } else if (expression) {
        statement;
        ...
    } else {
        statement;
        ...
    }
    ```
<br>

* switch-case语句
    * 若无 break，语句会从给定的标识一直执行到最后
        * 如果某条case有语句，且不break，要继续执行下一个case语句，此时最好下一个case前加上如下语句告诉编译器不要报警告
            * `[[ fallthrough ]]` / `[[ __fallthrough__ ]]` ：C++17/C23 标准
            * `__attribute__((fallthrough));` ：GCC/CLANG私有扩展
    * case 标号必须是整型常量表达式
    * GCC/CLANG标号语法扩展：支持多个值 `case 1,2:` 和范围值 `case 1...10:`
    * C++17可以在 `switch` 中定义变量 `switch (定义变量; 标识变量名)`
    ```cxx
    switch (标识变量名) {
    case 标识1: statement1; break;
    case 标识2: statement2; break;
    case 标识3: statement3; break;
    case 标识4: statement4; break;
    ...
    default:    statementn; break;
    }
    ```
<br>

* 条件运算符
    * 若表达式1为真，执行2，否则执行3
    * 条件表达式可以嵌套，例如 `cond1?expr1:cond2?expr21:expr22`
    ```cxx
    expression1 ? expression2 : expression3
    ```

### 循环

* 入口条件循环
    * 先判断条件，为真则再执行循环
    * C++17可以在while中定义变量 `while (定义变量; expression)`
    ```cxx
    while (expression) {
        statement;
        ...
    }
    ```
<br>

* 退出条件循环
    * 先执行循环，再判断条件，为真则继续执行循环
    * 常用 `#define func_name(var) do { statement; } while(0)`
    ```cxx
    do {
        statement;
        ...
    } while(expression);
    ```
<br>

* for循环
    * for内表达式可以为空，但不能省略分号 `;`
    * intialize和update可以用逗号 `,` 隔开的多个语句
    * C++/C11可在intialize中定义新变量，一般也建议这么做
    ```cxx
    for(intialize; test; update) {
        statement;
        ...
    }
    ```
<br>

* for范围循环(C++11)
    * for范围循环对元素集合的每一个元素进行遍历
    * 如果要对元素执行写操作，必须定义为引用类型，每次迭代都会重新定义循环控制变量，并将其初始化为序列中的下一个值
    * for范围循环处理多维数组时，除最里层循环外，其它所有循环的控制变量要用引用&
    * 序列拥有能返回迭代器的 `begin` 和 `end` 成员
    ```cxx
    for(元素类型 控制变量:序列) {
        statement;
        ...
    }
    ```
    * 举例
    ```cxx
    vector<int> v={0,1,2,3,4,5,6,7,8,9};
    for(auto &r: v) {
        r *= 2;
    }
    // 等价于
    for(auto beg=v.begin(), end=v.end(); beg!=end; ++beg) {
        auto &r = *beg;
        r *= 2;
    }
    ```

* 改变循环流程
    * `continue`    : 跳过它后面的循环语句，执行下一次循环(for循环跳出循环前要执行update)
    * `break`       : 跳出这个循环，不在执行
    * `goto label`  : 直接跳到标签名处。一般用于跳出深层循环和错误处理
        * 定义标签 `标签名: 语句;`
        * `goto` 语句不能跨越变量的定义语句向前跳转
            * 如果需要在goto和其跳转对应的标号之间定义变量，则定义必须放在一个块语句中
            * 向前跳过未执行的变量定义语句，意味着变量可能在没有定义的情况下使用
            * 向后跳回到一个变量定义之前，则会使系统撤销这个变量，然后再重新创建它
        * 标号标识符可以与变量名以及程序里的其他标识符一样，不与别的标识符重名
        * goto 语句和获得所转移的控制权的带标号的语句必须位于于同一个函数内

### 异常处理(C++)

* C++异常处理中包括
    1. `throw` 表达式，错误检测部分使用这种表达式来说明遇到了不可处理的错误，可以说 throw 引发了异常条件
    2. `try` 块，异常处理部分使用它来处理异常。try 语句块以 try 关键字开始，并以一个或多个 catch 子句结束。在 try 块中执行的代码所抛出(throw)的异常，通常会被其中一个 catch 子句处理。由于它们“处理”异常，catch 子句也称为异常处理代码
    3. 由标准库定义的一组异常类，用来在 throw 和相应的 catch 之间传递有关的错误信息

* try 块的通用语法形式
    ```cxx
    try {
        program-statements;
    } catch(exception-specifier) {
        handler-statements;
    } catch(exception-specifier) {
        handler-statements;
    } catch(...) { // 通配符catch块
        handler-statements;
    }
    ```
    * try 块以关键字 try 开始，后面是用花括号起来的语句序列块
    * try 块后面是一个或多个 catch 子句
    * 每个 catch 子句包括三部分：关键字 catch，圆括号内单个类型或者单个对象的声明——称为异常说明符，以及通常用花括号括起来的语句块
    * 如果选择了一个 catch 子句来处理异常，则执行相关的块语句，一旦 catch 子句执行结束，程序流程立即继续执行紧随着最后一个 catch 子句的语句
    * 如果不存在处理该异常的 catch 子句，程序的运行就要跳转到名为 terminate 的标准库函数，该函数在 exception 头文件中定义，这个标准库函数的行为依赖于系统，通常情况下，它的执行将导致程序非正常退出
        1. exception 头文件定义了最常见的异常类，它的类名是 exception，这个类只通知异常的产生，但不会提供更多的信息
        2. stdexcept 头文件定义了几种常见的异常类
        3. new 头文件定义了 bad_alloc 异常类型，提供因无法分配内在而由 new 抛出的异常
        4. type_info 头文件定义了 bad_cast 异常类型

        * stdexcept 头文件中定义的标准异常类
            | exception         | 最常见的问题 |
            | ---               | --- |
            | runtime_error     | 运行时错误：仅在运行时才能检测到问题 |
            | range_error       | 运行时错误：生成的结果超出了有意义的值域范围 |
            | overflow_error    | 运行时错误：计算上溢 |
            | underflow_error   | 运行时错误：计算下溢 |
            | logic_error       | 逻辑错误：可在运行前检测到问题 |
            | domain_error      | 逻辑错误：参数的结果值不存在 |
            | invalid_argument  | 逻辑错误：不合适的参数 |
            | length_error      | 逻辑错误：试图生成一个超出该类型最大长度的对象 |
            | out_of_range      | 逻辑错误：使用一个超出有效范围的值 |
<br>

例子

```cxx
#include <iostream>
#include <stdexcept> // 包含标准异常类
#include <string>

// 自定义异常类，继承自std::exception
class MyCustomException : public std::exception {
public:
    MyCustomException(const std::string& message)
        : message_(message) {}

    virtual const char* what() const noexcept override {
        return message_.c_str();
    }

private:
    std::string message_;
};

int main() {
    try {
        // 可能抛出异常的代码
        int number = 0;
        if (number == 0) {
            throw std::runtime_error("Division by zero!"); // 抛出标准异常
        }
        // 假设这里还有其他代码，可能抛出MyCustomException
        // ...
        throw MyCustomException("Something went wrong in the program."); // 抛出自定义异常

        // 注意：上面的throw语句会导致下面的代码不会被执行
        std::cout << "This line will not be reached." << std::endl;

    } catch (const std::runtime_error& e) {
        // 捕捉并处理std::runtime_error类型的异常
        std::cerr << "Caught a runtime_error: " << e.what() << std::endl;
    } catch (const MyCustomException& e) {
        // 捕捉并处理MyCustomException类型的异常
        std::cerr << "Caught a MyCustomException: " << e.what() << std::endl;
    } catch (...) {
        // 捕捉所有其他类型的异常(这是一个通配符catch块)
        std::cerr << "Caught an unknown exception." << std::endl;
    }

    // 无论是否发生异常，这里的代码都会被执行
    std::cout << "Program continues after try-catch block." << std::endl;

    return 0;
}
```

## 函数

```c
返回类型 函数名(Type1 Name1, Type2 Name2) {}
函数名(Type1 Name1, Type2 Name2) -> 返回类型  {} // 尾置返回 C++
```

### 函数说明

* 函数定义
    * 函数定义两种方式：
        * C/C++：`前置函数修饰符 返回类型 函数名(参数列表) 后置函数修饰符 {函数体}`
        * C++  ：`前置函数修饰符 auto 函数名(参数列表) 后置函数修饰符 -> decltype(expr) {函数体}`
    * 前置函数修饰符:
        * C/C++：`static` `inline`
        * C++  ： `constexpr` `virtual` `explicit` `[[noreturn]]`
    * 后置函数修饰符:
        * C++  ：`const` `noexcept` `final` `override`
    * 函数名后面只有空括号，C表示参数列表静默，由后面定义(C23非法)；C++表示没有参数
    * 函数形参是数组，传递的是到数组首元素的指针；函数中对数组进行更改，函数结束后效果仍然存在；由于传递的指针，所以不知道数组元素的个数
        * 函数不能返回数组或函数，但可以返回他们的指针
    * 内联函数
        * 每调用一次都是复制一份；函数声明和定义前加inline，内联函数是内部链接
<br>

* `类型 函数名(Type1, Type2 = Value2, Type2 = Value2);` ：默认值(C++)
    * 默认参数的类型在声明时检查，在调用时求值
    * 没有默认值的参数一定要在最前，只能在调用函数的排列在最后参数提供默认值，同一作用域不能重复或改变默认值
    * 一般在声明中指明默认实参，并放在合适的头文件中
<br>

* 函数调用
    * 函数调用做了两件事情：
        * 用对应的实参初始化函数的形参，并将控制权转移给被调用函数
        * 主调函数的执行被挂起，被调函数开始执行
    * 函数的运行以形参的(隐式)定义和初始化开始
    * 参数传递
        * 当形参是引用类型时，它对应的实参被引用传递(passed by reference)，函数被传引用调用(called by reference)。引用形参是它对应实参的别名
            * 通过使用引用形参，函数可以改变实参的值
        * 当形参不是引用类型时，形参和实参是两个相互独立的对象，实参的值会被拷贝给形参(值传递，passed by value)，函数被传值调用(called by value)
            * 函数对形参做的所有操作都不会影响实参
            * 使用指针类型的形参可以访问或修改函数外部的对象
    * `return` 语句结束函数的执行过程，完成两项工作：
        * 返回return语句中的值(可能没有值)
        * 将控制权从被调函数转移回主调函数，函数的返回值用于初始化调用表达式的结果
            * 注：不要返回局部变量的引用或指针
            * 调用一个返回引用的函数会得到左值，其他返回类型得到右值

### 内联函数inline

* inline 当编译器发现某段代码在调用一个内联函数时，它不是去调用该函数，而是将该函数的代码，整段插入到当前位置
    * 内联函数的本质是，节省时间但是消耗空间
    * 好处: 省去了调用的过程，加快程序运行速度(函数的调用过程，由于有参数入栈等操作，所以总要多占用一些时间)
    * 坏处：程序的体积将增大
    * 慎用内联
        * 内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率
        * 如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少
        * 另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间
<br>

* inline函数的规则
    * 含有递归调用的函数不能设置为inline
    * 使用了复杂流程控制语句：循环语句和switch语句，无法设置为inline
    * 由于inline增加体积的特性，所以建议inline函数内的代码应很短小
    * inline仅做为一种“请求”，特定的情况下，编译器将不理会inline关键字，而强制让函数成为普通函数。出现这种情况，编译器会给出警告消息
    * 为了调试方便，在程序处于调试阶段时，所有内联函数都不被实现
    * 在你调用一个内联函数之前，这个函数一定要在之前有声明或已定义为inline
        * 如果在前面声明为普通函数，而在调用代码后面才定义为一个inline函数，程序可以通过编译，但该函数没有实现inline
        ```cxx
        //函数一开始没有被声明为inline:
        void foo();
        //然后就有代码调用它：
        foo();
        //在调用后才有定义函数为inline:
        inline void foo()
        {
            ...
        }
        //代码是的foo()函数最终没有实现inline;
        ```
<br>

* 类内联函数
    * 定义在类声明之中的成员函数将自动地成为内联函数
        ```cxx
        class A {
        public:
            void Foo(int x, int y) { } // 自动地成为内联函数
        };
        ```
    * 定义在类外的成员函数可以显式指定为内联函数
        ```cxx
        // 头文件
        class A {
        public:
            void Foo(int x, int y);
        }
        // 定义文件
        inline void A::Foo(int x, int y){}
        ```
<br>

* 使用内联函数时注意
    * 在函数声明或定义中函数返回类型前加上关键字inline，即可以把函数指定为内联函数
    * 关键字inline必须与函数定义放在一起才能使函数成为内联，仅仅将inline放在函数声明前面不起任何作用
    * 在一个文件中定义的内联函数不能在另一个文件中使用，它们通常放在头文件中共享
    * 内联函数应该简洁，只有几个语句，如果语句较多，不适合于定义为内联函数
    * 内联函数体中，不能有循环语句、if语句或switch语句，否则，函数定义时即使有inline关键字，编译器也会把该函数作为非内联函数处理(现代编译器内内联没有这么要求严格)
<br>

* 以下情况不宜使用内联：
    * 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高
    * 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大
    * 类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联(这进一步说明了 inline 不应该出现在函数的声明中)

### 函数重载(C++)

同名函数具有不同的参数列表称为重载。

* 重载调用原则优先级
    * 根据函数调用的参数类型和个数使用同一名称的不同函数，重载解析不考虑函数返回值类型
    * 如果能找到最高的同一优先级有两个匹配，会拒绝调用(重载分不清 `Type / Type&`)
    * 入函数有多个参数时，若一个参数有最佳匹配，其他参数优先级不低于其它函数的参数，才调用这个函数；若没有这个函数，调用将会被拒绝
        * 准确匹配
        * 提升匹配(整型提升：bool、char、short到int，int到long；浮点提升：float到double)
        * 标准转换(如int到double，double到int，signed到unsigned， `T*` 到 `void*` )
        * 用户定义转换
        * 函数参数列表省略号...  //不知道后面的参数类型和个数，声明时用...代替
<br>

* const参数
    * 可以同时定义参数类型相同但const性不同的同名函数
    * 非const参数调用时，编译器优先查找非const参数函数，找不到可隐式添加const转换调用const参数函数
    * const参数调用只能匹配const参数函数，找不到会引发编译错误(权限放大禁止)

    | 调用场景             | 匹配的函数版本    |
    | -------------------- | ----------------- |
    | 非const对象/参数调用 | 非const版本优先   |
    | const 对象/参数调用  | 只能调用const版本 |
    | 传递字面量或临时对象 | 只能调用const版本 |

### lambda表达式(C++)

```cxx
[capture-list](params) mutable(可选) noexcept(可选) -> return-type { body }
```

* 位于 `[]` 中的捕获列表，可能为空，指明定义环境中的哪些名字能用在表达式中，以及访问这些名字的方式是复制还是引用
    * `[]` : 空捕获列表，所有局部名字都不可访问
    * `[&]` : 引用捕获列表，所有局部名字都通过引用访问
    * `[=]` : 值捕获列表，所有局部名字都通过副本访问
        * **被捕获的变量在lambda表达式被创建时拷贝，而不是运行时**
    * `[捕获列表]` : 捕获列表中名字前有 `&` 时通过引用访问，否则通过副本访问
        * `this` : 表明类的成员都可以通过引用访问
        * `*this` : 表明类的成员都可以通过值访问
    * `[&,捕获列表]` : 捕获列表中名字前通过副本访问，捕获列表中名字前不能有 `&` ，否则通过引用访问，捕获列表中可以出现 `this`
    * `[=,捕获列表]` : 捕获列表中名字前通过引用访问，捕获列表中名字前要有 `&`，否则通过副本访问，捕获列表中不可以出现 `this`
    * 表示式捕获：捕获列表允许右值的捕获，即允许捕获列表中使用表达式 (C++14)
    * 名字空间(包含全局空间)的变量永远是可访问的
* 位于 `()` 中的参数列表，可能忽略，lambda表达式的最简方式是 `[]{}`
    * 泛型参数：参数允许使用 `auto` 泛型参数 (C++14)
* 可选的修饰符
    * `mutable` ：允许修改值捕获的副本(不影响原变量)，默认是 `const`
    * `noexcept` : 不抛出异常
* 可选的返回类型声明 `->`
    * 函数体不包含 `return` 语句表明返回类型是 `void`
    * 函数体只包含一条 `return` 语句返回类型自动推断，复杂逻辑需要显式指定
    * 其它情况必须加上返回类型声明
* 位于 `{ }` 中的函数体
    * 具体运行逻辑
<br>

* 允许lambda使用模板参数列表，实现严格的类型约束和泛型编程(C++20)
    ```cxx
    // 显式声明模板参数，强制类型一致
    auto max = []<typename T>(T a, T b) { return a > b ? a : b; };
    int result = max(42, 24);  // ✅ 合法
    // int err = max(42, 24.5); // ❌ 编译错误：类型不匹配
    ```

### 函数对象包装器(C++11)

* `std::function<返回值(参数列表)>`
    * 一种通用、多态的函数封装(函数的容器)， 能够更加方便的将函数、函数指针作为对象进行处理
* `std::bind(原函数, std::placeholders::_1, 固定值, ...)`
    * 绑定函数调用的参数，可以改变参数传参个数和顺序
    * `std::placeholders::_1` 表示调用绑定函数时的第1个参数，`_2` 表示第2个参数，依此类推
    * 例子调用 `testbind(m, n)` 即是调用 `test(n, m, 10, 100)`
        ```cxx
        int test(int a, int b, int c, int d);
        auto testbind = std::bind(std::placeholders::_2, std::placeholders::_1, 10, 100);
        ```

### 函数指针

* 声明方法
    * `返回类型 (*函数指针名)(参数列表);` // **函数指针名的括号不可省略**
* 定义别名
    * `typedef 返回类型 (*函数指针别名)(参数列表);`
    * `using 函数指针别名 = 返回类型 (*)(参数列表);`
* 赋值方法
    * 普通全局函数
    * 类的静态成员函数
    * 捕获列表为空的lambda表达式
    * 因类型和机制差异，`std::function` 无法隐式转换为函数指针
* 调用方法
    * `函数指针名(参数列表)` 或 `(*函数指针名)(参数列表)`
        * 调用前可检查函数指针是否为nullptr

## 数组array

数组是一种数据格式，能够存储多个同类型的值。

* 定义数组：`typename arrayname[arraysize];`
    * typename存储在每个元素中的值的类型
        * 可以是内置数据类型或类类型
        * **除引用之外**，数组元素的类型还可以是任意的复合类型
    * arrayname：数组名
    * arraysize：数组中的元素个数，数组的长度是固定的，
        * 整型字面值常量、枚举常量或const值或常量表达式
<br>

* 初始化数组
    * 允许在声明语句中初始化数组元素，只需提供一个用逗号分隔的值列表(**初始化列表**)，并将它们用花括号括起即可
        * `const unsigned array_size = 3;`
        * `int ia[array_size] = {0, 1, 2};`
    * 初始化列表提供的元素个数不能超过数组长度，数组长度大于列出的元素初值个数，则只初始化前面的数组元素；剩下的其他元素，若是内置类型则初始化为 0，若是类类型则调用该类的默认构造函数进行初始化
        * `int ia[3] = {0, 1}; // ia[2] 被初始化为0`
    * 显式初始化的数组不需要指定数组的维数值，编译器会根据列出的元素个数来确定数组的长度：
        * `int ia[] = {0, 1, 2}; // an array of dimension 3`
    * 如果没有显式提供元素初值，则数组元素会像普通变量一样初始化
        * 在函数体外定义的内置数组，其元素均初始化为 0
        * 在函数体内定义的内置数组，其元素无初始化
        * 不管数组在哪里定义，如果其元素为类类型，则自动调用该类的默认构造函数进行初始化；如果该类没有默认构造函数，则必须为该数组的元素提供显式初始化
    * 一个数组不能用另外一个数组初始化，也不能将一个数组赋值给另一个数组
    * 初始化数组时，可省略等号`=` (c++11)
        * 在大括号内包含任何东西，这将把所有元素都设置为零
        * 列表初始化禁止缩窄转换
        ```cxx
        char ca[4] {'C', '+', '+', '\0'}; // ok
        char ca[4] = {}; // ok, all 0
        char ca[4] {};   // ok, all 0
        char ca[] {'C', '+', '+', '\0'};  // not allowed
        char ca[4] {'C', '+', '+'};       // not allowed
        char ca[] {1000, '+', '+', '\0'}; // not allowed
        ```
<br>

* 访问数组：`arrayname[index]`
    * 第一个元素的索引(下标)是 `0`，最后一个元素的索引是`arraysize-1`
    * 编译器不会检查使用的索引是否有效
<br>

* 数组和指针、引用
    * 复合类型数组
        * `类型(*数组名)[元素个数]` 数组的指针
        * `类型 *数组名[元素个数]` 数组元素为指针的数组
        * `类型 *(&数组名)[元素个数]` 数组元素为指针的数组的引用
        * `类型(&数组名)[元素个数]` 数组的引用
        * `类型 &数组名[元素个数]` 不能这么用，**没有引用的数组**
    * 大多数表达式中，使用类型为数组的对象转化为指向该数组首元素的指针
        * 数组若用 `decltype` 限定，或被 `sizeof`、取地址 `&` 及 `typeid` 操作，不会隐式转换为数组首元素的指针
<br>

* 多维数组
    * 定义
        ```cxx
        int ia[3][4] = {
            {0, 1, 2, 3},
            {4, 5, 6, 7},
            {8, 9, 10, 11}
        }; /* 3 elements, each element is an array of 4 elements */

        // 等价int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
        ```
    * 把一个字符串数组的首地址赋给一个指向字符的指针
        ```cxx
        char s[4][6]={"abc","1234","xyz56","mn"}; //字符串数组
        char *p;
        p=s;
        p=&s;
        p=s[0];
        p=&s[0];
        p=&s[0][0];
        printf("%s\n",p); //输出都是abc。
        ```
    * `foreach`循环处理多维数组时，除最里层循环外，其它所有循环的控制变量要用引用&，集合名不用加
<br>

* 数组动态申请释放(C++)
    * 创建动态数组
        * `int *pia = new int[10]; // array of 10 uninitialized ints`
        * `int *pia2 = new int[10](); // array of 10 initialized ints`
        * 在数组长度后面的一对**空圆括号**，对数组元素做值初始化。圆括号要求编译器对数组做值初始化，在本例中即把数组元素都设置为 0
        * 对于动态分配的数组，其元素只能初始化为元素类型的默认值，而不能像数组变量一样，用初始化列表为数组元素提供各不相同的初值
        * 调用 new 动态创建长度为 0 的数组是合法的。 new 动态创建长度为 0 的数组时，new 返回有效的非零指针。该指针与 new 返回的其他指针不同，不能进行解引用操作，因为它毕竟没有指向任何元素
    * 释放动态数组
        * `delete[] pia;`
        * 该语句回收了 pia 所指向的数组，把相应的内存返还给自由存储区。**在关键字 `delete` 和指针之间的空方括号对是必不可少的**。如果遗漏了空方括号对，这是一个编译器无法发现的错误，将导致程序在运行时出错
    * 使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置
    * 使用 `new[ ]` 运算符创建数组时，将采用动态联编(动态数组)，即将在运行时为数组分配空间，其长度也将在运行时设置
<br>

* 字符串
    * 字符串字面值的类型就是 `const char` 类型的数组
        * C++11 禁止如下语句 `char *pstr = "abc"` (C和旧式C++可以)，必须使用 `const char *pstr = "abc"`
    * 字符串字面值包含一个**额外的空字符(`'\0'`)**用于结束字符串
    * 当使用字符串字面值来初始化创建的新数组时，将在新数组中加入空字符`'\0'`
        * `char ca[] = {'C', '+', '+', '\0'};` 或 `char ca[] = "C++";`
    * 长字符串有如下分割语法 `"abc"  "ABC"` 等效 `"abcABC"`

## 指针

### 裸指针

* `类型 *指针名=指针值` or `类型 *指针名 = &对象名;`

* 指针本身是一个对象，用于指向对象，存放某个对象的地址，指针类型必须与对象的类型相同
* 如果需要在一个声明语句中定义两个指针，必须在每个变量标识符前再加符号 `*` 声明：`string *ps1, *ps2;`
* 一定要在对指针应用解除引用运算符`*`之前，将指针初始化为一个确定的、适当的地址
* 允许对指针赋值，拷贝，更改指向，无需定义时赋初值，不能定义指向引用的指针
<br>

* `void*`：指向未知类型的指针
    * 可以保存任何类型对象(除去函数指针和指向类成员的指针)的地址
    * `void*` 表明该指针与一地址值相关，但不清楚存储在此地址上的对象的类型
    * `void*` 指针只支持几种有限的操作：与另一个指针进行比较；向函数传递 `void*` 指针或从函数返回 `void*` 指针；给另一个 `void*` 指针赋值
    * 不允许使用 `void*` 指针操纵它所指向的对象
<br>

* 引用和指针对比
    * 相同：都可间接访问另一个值
    * 区别1：引用总是指向某个对象，定义引用时没有初始化是错误的
    * 区别2：是赋值行为的差异，给引用赋值修改的是该引用所关联的对象的值，而并不是使引用与另一个对象关联。引用一经初始化，就始终指向同一个特定对象(这就是为什么引用必须在定义时初始化的原因)
<br>

* 指针运算
    * 指针的值(即地址)应属于下列状态之一：
        * 指向一个对象
        * 指向紧邻对象所占空间的下一个位置
        * 空指针，即指针没有指向任何对象
            * `NULL` ：预处理变量，定义于头文件`stdlib.h`中，值为0 `#define NULL (void*)0`
            * `nullptr` (C++11/C23)：不能将nullptr赋值给整型，引入nullptr根本原因和C++的重载函数有关
        * 无效指针，即上述情况之外的其他值
    * 解引用操作符 `*` 将获取指针所指的对象
        * 如果对左操作数进行解引用，则修改的是指针所指对象的值
        * 如果没有使用解引用操作，则修改的是指针本身的值
        * **后自增操作的优先级高于解引用操作**
    * 指向相同类型对象的指针可以比较是否相等，比较的是地址
        * 地址相同情况：指向同一对象；指向同一对象的下一地址；为空 `nullptr`
    * 指针上加上(或减去)一个整型数值 n 等效于获得一个新指针，**该新指针指向指针原来指向的元素之后(或之前)的第 n 个元素**
    * 两个指针减法操作的结果是标准库类型(library type) ptrdiff_t 的数据
    * 允许在指针上加减 0，使指针保持不变。更有趣的是，如果一指针具有 0 值(空指针)，则在该指针上加 0 仍然是合法的，结果得到另一个值为 0 的指针。也可以对两个空指针做减法操作，得到的结果仍是 0
    * 如果指针的值为 0，则在其上做 delete 操作是合法的，但这样做没有任何意义
<br>

* 指针const修饰符：一个指针本身添加const限定符就是顶层const，而指针所指的对象添加const限定符就是底层const
    * **顶层const**常量指针：代表指针本身是常量
        * 声明时const必须放在指针符号后面，即：`*const`
        * 声明时必须初始化，之后它存储的地址值就不能再改变
        ```cxx
        int num_b = 2;
        int *const p_b = &num_b; //顶层const
        // p_b = &num_a;  //错误，常量指针不能改变存储的地址值
        ```
        * const普通变量也是顶层const，声明时const可以放在类型名前后都可，拿int类型来说，声明时：`const int` 和 `int const` 是等价的
    * **底层const**指向常量的指针：代表不能改变其指向内容的指针
        * 指向“常量”的指针不代表它所指向的内容一定是常量，只是代表不能通过解引用符(操作符*)来改变它所指向的内容
        ```cxx
        int num_a = 1;
        int const  *p_a = &num_a; //底层const
        const int *p_a = &num_a; //底层const
        // *p_a = 2;  //错误，指向“常量”的指针不能改变所指的对象
        // p_a指向的内容就不是常量，可以通过赋值语句：num_a=2;  来改变它所指向的内容。
        ```
<br>

* 指针转换
    * 在使用数组时，大多数情况下数组都会自动转换为指向第一个元素的指针
        * 不将数组转换为指针的例外情况有:
            * 数组被用作 `decltype` (返回表达式的类型(包括顶层const和引用在内))的参数时
            * 数组用作取地址操作符 `&` 或 `sizeof` 操作符或 `typeid` 的操作数时
            * 用数组对数组的引用进行初始化时，不会将数组转换为指针
    * 指向任意非常量的指针都可转换为 `void*` 类型；指向任意对象的指针都可转换为 `const void*` 类型;
    * 整型数值常量 `(void *)0` (C23前) 和 `nullptr`字面值(C++11/C23) 可转换为任意指针类型

### 智能指针(C++11)

C++智能指针是C++11引入的核心内存管理工具，基于RAII(资源获取即初始化)机制，自动管理动态分配的内存，避免内存泄漏、悬空指针等问题。

* 智能指针的核心原理
    * RAII机制(Resource Acquisition Is Initialization)
        * 资源在对象构造时获取，在析构时自动释放
        * 智能指针将原始指针封装为类对象，利用析构函数自动调用 `delete` 或自定义删除器，避免手动 `delete` 遗漏导致内存泄漏
    * 行为模拟指针
        * 智能指针不是指针(不代表一个内存地址)，而是一个类对象
        * 通过重载 `operator*()` 和 `operator->()` ，支持类似原始指针的语法
        * 通过 `.get()` 获取原始指针(需谨慎使用)

* 智能指针类型
    | 特性      | `std::unique_ptr`            | `std::shared_ptr`            | `std::weak_ptr`        |
    |-----------|------------------------------|------------------------------|------------------------|
    | 所有权    | 独占                         | 共享                         | 无(观察者)             |
    | 拷贝/赋值 | ❌(仅移动)                   | ✅(引用计数复制增加/移动不变)| ✅(不增加引用计数)     |
    | 性能开销  | 无额外开销                   | 控制块+原子操作              | 控制块                 |
    | 典型场景  | 独占资源、工厂模式返回值     | 多组件共享资源               | 打破循环引用、缓存系统 |
    | 线程安全  | 对象访问需同步               | 引用计数安全，对象访问需同步 | 同`shared_ptr`         |

* 三种智能指针详解
    * `std::unique_ptr` (独占所有权)
        * 独占资源，禁止拷贝(拷贝构造函数和赋值运算符被 `delete` )
        * 支持移动语义(`std::move`转移所有权)
        * 零额外开销(性能接近原始指针)
        * 可通过 `release()` 放弃所有权返回原始指针
        ```cxx
        auto ptr = std::make_unique<int>(42);  // C++14推荐方式(C++11不支持)
        auto ptr2 = std::move(ptr);            // 所有权转移
        ```
    * `std::shared_ptr` (共享所有权)
        * 多个 `shared_ptr` 共享资源，内部维护控制块(含强引用计数和弱引用计数)
        * 引用计数线程安全：引用计数的增减是原子操作(但对象访问需额外同步)
        * 允许拷贝运算和赋值，引用计数随拷贝增加
        * 对象销毁(离开作用域，被赋他值，显式调用 `reset()` 等)引用计数减少，强引用计数归零时释放资源
        * 可通过 `get()` 获取其管理的原始指针，但需注意不转移所有权和不手动释放
        ```cxx
        auto ptr1 = std::make_shared<MyClass>(); // 一次分配对象+控制块
        auto ptr2 = ptr1;                        // 引用计数+1
        ```
    * `std::weak_ptr` (弱引用)
        * 不增加强引用计数，仅观察 `shared_ptr` 管理的资源。
        * 可通过 `lock()` 获取临时 `shared_ptr` 对象访问资源(需检查有效性)
        ```cxx
        std::weak_ptr<MyClass> weak = a_shared_ptr;
        if (auto sptr = weak.lock()) {           // 检查资源有效性
            sptr->use();
        }
        ```
        * 主要是为了解决循环引用，引用计数永不为零，导致内存泄漏
        ```cxx
        /* 循环引用问题导致内存泄漏，这时应该其中一个定义为weak_ptr或手动reset()释放 */
        class A { std::shared_ptr<B> b_ptr; };
        class B { std::shared_ptr<A> a_ptr; };
        ```
<br>

* 三类智能指针运算支持对比
    | 运算            | `unique_ptr` | `shared_ptr` | `weak_ptr` | 说明         |
    |-----------------|--------------|--------------|------------|--------------|
    | `*` / `->`      | ✅           | ✅           | ❌         | 基础访问     |
    | `operator bool` | ✅           | ✅           | ✅         | 判空操作     |
    | 移动赋值        | ✅           | ✅           | ✅         | 所有权转移   |
    | 拷贝赋值        | ❌           | ✅           | ✅         | 共享所有权   |
    | `reset()`       | ✅           | ✅           | ❌         | 主动释放资源 |
    | 赋值 `nullptr`  | ✅           | ✅           | ✅         | 等同reset    |
    | `release()`     | ✅           | ❌           | ❌         | 放弃所有权   |
    | `get()`         | ✅           | ✅           | ❌         | 获取原始指针 |
    | `lock()`        | ❌           | ❌           | ✅         | 弱引用升级   |
    | `operator[]`    | ✅(仅数组)   | ❌           | ❌         | 数组访问     |
    | `use_count()`   | ❌           | ✅           | ❌         | 引用计数查询 |

    * 数组下标 `[]` ：直接访问数组元素
        ```cxx
        auto arr = std::make_unique<int[]>(5);
        arr[0] = 10;  // 访问第0个元素
        ```
    * 自定义删除器 ：管理非内存资源(例如文件句柄)
        ```cxx
        auto file_closer = FILE* f { fclose(f); };
        std::unique_ptr<FILE, decltype(file_closer)> file(fopen("a.txt", "r"), file_closer);
        ```

<br>

* `shared_from_this()` ：this共享指针
    * 共享享控制块，引用计数统一管理，避免双重释放
    * 需保证仅在对象已被shared_ptr管理后才能调用 `shared_from_this()` (C++11) 和 `weak_from_this()` (C++17)
    * 禁止在构造函数和析构函数中调用
    * 避免重复继承 enable_shared_from_this，若多继承将之作为首个基类的基类，避免指针偏移问题
    ```cxx
    class MyClass : public std::enable_shared_from_this<MyClass> {
    public:
        std::shared_ptr<MyClass> getPtr() {
            return shared_from_this(); // 安全共享所有权
        }
    };
    ```

## 引用(C++)

### 左值右值

* 左值(lvalue, left value)：表达式后依然存在的持久对象，具名且可寻址
    * 左值可以出现在赋值语句的左边或右边
    * 当一个表达式用于左值时，用的是对象的身份(在内存中的位置)
    * 可以取地址，有名字的是左值(例如变量是左值)
* 右值(rvalue, right value)：表达式结束后就不再存在的临时对象，不可寻址
    * 右值只能出现在赋值的右边，不能出现在左边
    * 当一个表达式用于用于右值时，用的是对象的值(内容)
    * 不可以取地址，没有名字的是右值(字面值是右值)
    * 右值进一步划分为纯右值和将亡值
<br>

* 纯右值(prvalue, pure rvalue)：纯粹的右值
    * 跟对象不相关的字面值
    * 函数非引用返回的临时变量
    * 运算表达式产生的临时变量
    * 类型转换函数的返回值
    * lambda表达式
* 将亡值(xvalue, expiring value)：即将被销毁却能够被移动的值(C++11)
    * 返回右值引用T&& 的函数返回值
    * std::move()的返回值
    * 转换为T&&的类型转换函数的返回值

### 左值右值引用

* 引用
    * 引用本身不是一个对象，只是为已经存在的对象定义一个别名，对引用的操作即是对它绑定的对象进行操作
    * 引用必须和它绑定对象的类型严格匹配
    * 定义引用时必须同时初始化，没有空引用，一旦定义引用，引用就和这个对象绑在一起，不能重新绑定另一个对象
        * 而指针可以在不同时刻指向不同的对象
    * 不能定义引用的引用
        * 指针可以在不同时刻指向不同的对象
<br>

* `类型 &引用名=对象名;` ：左值引用
    * 左值引用必须绑定在左值上(变量)，不能绑定字面值或表达式结果
<br>

* `const 类型 &引用名=对象名;` ：常量引用
    * 常量引用可以绑定左值和右值上
    * 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可
    * 允许为一个常量引用绑定非常量的对象、字面值或者一般表达式
<br>

* `类型 &&引用名=右值;` ：右值引用(C++11)
    * 右值引用必须绑定在右值上，右值引用是为了避免拷贝提高性能
    * 右值引用是没有变量名的变量值的别名，右值引用的变量的的生命周期直到右值引用消亡
    * 通过 `std::move` 可将左值转为右值引用，对象所有权转移发生在移动构造/移动赋值时
<br>

### 模板完美转发

* 引用折叠(Reference Collapsing)
    * 在模板推导或typedef/using中，当引用的引用出现时，编译器按规则折叠引用类型：

    | 原始类型 | 折叠后类型 |
    | -------- | ---------- |
    | `T& &`   | `T&`       |
    | `T& &&`  | `T&`       |
    | `T&& &`  | `T&`       |
    | `T&& &&` | `T&&`      |

* 万能引用(Universal Reference)
    * `T&&` 只在模板中可绑定左值或右值，实际由折叠规则实现
    * 当一个右值(如临时对象)传入函数模板时，在函数内部具名化后，它会变成左值
    * `auto&&` 同样依赖类型推导，遵循相同的折叠规则
    ```cxx
    template<typename T>
    void forward(T&& t) {
        // t可接收左值或右值
    }
    int a = 10;
    forward(a);        // T推导为 `int&` ，折叠后t为 `int&`
    forward(10);       // T推导为 `int` ，折叠后t为 `int&&`

    int x = 10;
    auto&& ref1 = x;   // ref1为 `int&`
    auto&& ref2 = 20;  // ref2为 `int&&`
    ```

* 完美转发(Perfect Forwarding)
    * `std::forward` 保持参数的原始值类别(左值/右值)
        * 若T是左值引用，例如 `int&` → 返回 `static_cast<T&>(t)` (左值)
        * 若T是普通类型，例如 `int` → 返回 `static_cast<T&&>(t)` (右值)
    * 不使用完美转发时target的参数是左值引用或普通类型，永远调用的是左值类型
    ```cxx
    template<typename T>
    void wrapper(T&& arg) {
        // 转发 arg 的原始类型(左值仍为左值，右值仍为右值)
        target(std::forward<T>(arg));
    }
    ```

## 联合

### 传统联合union

```cxx
union 联合名 {
    类型名1 成员名1;
    类型名2 成员名2;
};
```

* `union` ：传统联合
    * 联合是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型，联合的长度为其最大成员的长度
    * C不支持默认值，C++支持默认值，但用在联合中的类型中的成员不能有默认值(多个类型默认值冲突)
    * C可以在结构体中定义匿名联合(没有联合名)，C++不能
    * C++限制联合中元素类型仅支持平凡类型(POD)，即不支持含构造、析构和虚函数的类

### 静态联合std::variant(C++17)

```cxx
#include <variant>
template<class... Types>
class variant;
```

* `std::variant` : 静态联合
    * 在编译时声明可存储的类型集合，例如： `std::variant<int, double, std::string>`
    * 一个variant的实例在任意时刻要么保有它的可选类型之一的值，要么在错误情况下无值
    * 内存占用为最大类型大小，无额外开销
    * 支持非平凡类型，类型安全，自动处理构造/析构
    * 不能保有引用、数组，或void

```cxx
std::variant<int, float> v, w;
v = 42; // v 含 int
int i = std::get<int>(v);
assert(42 == i); // 成功
w = std::get<int>(v);
w = std::get<0>(v); // 通过索引值获取
w = v; // 与前一行效果相同

// std::get<double>(v); // 错误：[int, float] 中无 double
// std::get<3>(v);      // 错误：有效索引值为 0 与 1

float *p = std::get_if<float>(v); // 支持通过类型或索引获取，失败返回nullptr
if (p) {
    std::cout << *p;
}

if (std::holds_alternative<float>(v)) { // 类型检查
    std::cout << std::get<float>(v);
}

try {
    std::cout << std::get<float>(w); // w 含 int 而非 float：会抛出异常
} catch (const std::bad_variant_access& ex) {
    std::cout << ex.what() << '\n';
}
```

* `std::visit` ：探测器

```cxx
using value_t = std::variant<int, long, double, std::string>;
std::vector<value_t> vec = {10, 15l, 1.5, "hello"};

for (auto&& v: vec) {
    // 1. void 探访器，仅为它的副作用而调用
    std::visit([](auto&& arg){ std::cout << arg; }, v);

    // 2. 返回值的探访器，演示返回另一变体的常见惯用法
    value_t w = std::visit([](auto&& arg) -> value_t { return arg + arg; }, v);

    // 3. 类型匹配探访器：以不同方式处理每个类型的 lambda
    std::cout << "。翻倍后，变体持有";
    std::visit([](auto&& arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, int>)
            std::cout << "值为 " << arg << " 的 int\n";
        else if constexpr (std::is_same_v<T, long>)
            std::cout << "值为 " << arg << " 的 long\n";
        else if constexpr (std::is_same_v<T, double>)
            std::cout << "值为 " << arg << " 的 double\n";
        else if constexpr (std::is_same_v<T, std::string>)
            std::cout << "值为 " << std::quoted(arg) << " 的 std::string\n";
        else
            static_assert(false, "探访器无法穷尽类型！");
    }, w);
}
```

### 动态联合std::any(C++17)

```cxx
#include <any>
class any;
```

* `std::any` ：动态联合
    * 一种可用于任何可复制构造类型的单个值的类型安全容器
    * 运行时类型识别：通过 `std::any_cast` 提取值，类型错误抛出 `std::bad_any_cast`
    * 可使用 `std::any make_any<T> ( Args&&... args );` 构造对象
    * 存储满足构造函数要求的任何类型的一个实例或为空，存储对象的副本而非引用
    * 存在运行时开销：大对象可能触发堆分配(小对象优化除外)；每次访问需类型检查(RTTI)

```cxx
auto val = std::any(12);
std::cout << "1) val 是 int：" << std::any_cast<int>(val) << std::endl;

if (val.type() == typeid(float)) { // 检查类型，typeid(void) 可检查空
    std::cout << "1) val 是 float：" << std::any_cast<float>(val) << std::endl;
}

try {
    auto s = std::any_cast<std::string>(val);
} catch (const std::bad_any_cast& e) { // 抛出异常
    std::cout << "3) " << e.what() << std::endl;
}

val.reset(); // 清空值
std::cout << "4) " << val.has_value() << std::endl; // 判定是否有值
```

```cxx
class Star {
    std::string name;
    int id;

public:
    Star(std::string name, int id) : name{name}, id{id} {
        std::cout << "Star::Star(string, int)\n";
    }
};

// emplace( Args&&... args );
val.emplace<Star>("Procyon", 2943); // 直接构造对象
```

## 枚举enum

```cxx
enum 枚举名 {
    成员名1,
    成员名2,
    成员名3
};
```

* 枚举定义了新的数值常量
* 默认地，第一个枚举成员赋值为 0，后面的每个枚举成员赋的值比前面的大1
* 可以通过显式地指定整数值来覆盖默认值
    * 例子 `enum Forms {shape = 1, sphere, cylinder=6, polygon};`
* 枚举类型的对象的初始化或赋值，只能通过其枚举成员或同一枚举类型的其他对象来进行
* 枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型
* 如果打算只使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称
<br>

* 可以在任何需要常量表达式的地方使用枚举成员。如：
    * 定义枚举类型的 `constexpr` 变量
    * 将枚举类型对象作为`switch`语句的表达式，而将枚举值作为`case`标签
    * 将枚举类型作为非类型模板形参使用
    * 在类的定义中初始化枚举类型的静态数据成员
<br>

```cxx
enum class 枚举名 : 基础类型 {
    成员名1,
    成员名2,
    成员名3
};
```

* 作用域枚举(scoped enumeration)(C++11)
    * 定义：`enum` 后面接 `class` 或 `struct`
    * 使用: `枚举名::成员名`
    * 显示指定枚举的基础类型，不指定时默认是int，例如 `enum class Color: char {red, green, blue}`
    * 区别：
        * 在限定作用域的枚举类型中，枚举成员的名字遵循常规作用域规则，并且在枚举类型的作用域外是不可访问的
            * 不能够被隐式的转换为整型，同时也不能够将其与整数数字进行比较，也不能对不同的枚举类型的枚举值进行比较
        * 与之相反，在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同
            * 不限定作用域的枚举类型对象或枚举成员能自动转换成整型

## 结构

### 传统结构struct

```cxx
struct 结构名 {
    类型名1 成员名1;
    类型名2 成员名2;
};
```

* `struct` 关键字在C++表示成员默认为 `public` 的类
* 结构是用户定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量
* 列表中的每一项都被称为结构成员
* 结构使用下面方式初始化
    * `struct 结构名 变量名 = {变量值1, 变量值2};`
    * `struct 结构名 变量名 = {.成员名1=变量值1, .成员名2=变量值2};`
    * 对首个元素是数字类型的初始化，C可以使用 `struct 结构名 变量名 = {0};` 初始化为0(**C++报部分初始化警告**)
* 结构使用下面方式访问成员：`结构变量名.成员名` `结构变量指针.成员名`
* 可以将结构作为参数传递给函数，也可以让函数返回一个结构
* 可以使用赋值运算符(=)将结构赋给另一个同类型的结构，这样结构中每个成员都将被设置为另一个结构中相应成员的值，这种赋值被称为成员赋值(memberwise assignment)
* 结构体大小不一定等于所有成员的大小之和，可能有空洞(例如4字节对齐)
    * gcc 可以在右大括号后加上 `__attribute__((__packed__))` 修饰结构体去除空洞
* 结构名定义就可以使用了，但此时无法获取它的大小
    * `struct bidlist {struct bidlist* prev; struct bidlist* next;};` 正确
    * `struct nogood {struct nogood member;};` 错误

```cxx
struct 结构名 {
    整型名1 成员名1 :宽度;
    整型名2 成员名2 :宽度;
};
```

* 位域：字段的类型应为整型或枚举，接下来是冒号，冒号后面是一个数字，它指定了使用的位数，每个成员都被称为位字段(bit field)
* 现代通用计算机(x86-64、ARM64)均为小端字节序 + LSB位序
    * 小端字节序：低位字节在前，高位字节在后；大端相反
    * LSB位序：低比特位在前，高比特位在后：MSB相反

### 元组std::tuple(C++11)

```cxx
#include <tuple>
template<class... Types>
class tuple;
```

`std::tuple` 是固定大小的不同类型的无名结构体(元组)

* 定义并初始化
    * `std::tuple<int, float, std::string> p1{1, 5.0, "Jing"};` ：列表初始化
    * `auto p2 = std::make_tuple(2, 4.1, "Tom");` ：make_tuple 自动推导初始化
* 访问元素
    * `std::get<0>(p1)` ：索引访问，获取第0个元素的引用
    * `std::get<int>(float)` ：类型访问(类型唯一时)，返回指定类型元素的引用
    * `auto [id, score, name] = p1;` ：结构化绑定，此时id=1，score=5.0，name="jing" (C++17)
    * `int id; float score; std::tie(id, score, std::ignore)` ：解包(类似结构化绑定)
        * `std::ignore` 表示忽略对应位置的元素
* 其它接口
    * `std::forward_as_tuple`：创建转发引用的元组，避免拷贝
        * 生成的元组元素类型是参数的引用类型
            * 若参数是左值 → 元组元素为左值引用(T&)
            * 若参数是右值 → 元组元素为右值引用(T&&)
        * 若元组中绑定了临时对象的右值引用，需确保元组在临时对象销毁前使用
        ```cxx
        int x = 42;
        auto tup = std::forward_as_tuple(x, std::string("temp"));
        // tup 类型：std::tuple<int&, std::string&&>
        ```
    * `std::tuple_cat(元组1, 元组2, ..., 元组n)` ：连接多个元组，返回一个新元组
    * `std::apply(函数名, 元组)`：将元组解包为传入的函数参数，返回函数的结果

## 类class(C++)

### 类思想
* 类背后的基本思想：**数据抽象**(data abstraction)和 **封装**(encapsulation)
    * 封装的益处
        * 确保用户的代码不会无意间破坏封装对象的状态
        * 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码
* 数据抽象是一种依赖于 **接口**(interface)和 **实现**(implementation)分离的编程技术
* 一个类就是一个包含其成员的名称空间
* 类可以嵌套，嵌套类可以访问外层类的成员，反之则不行

### 类定义

```cxx
class 类名 {
public:     // 公有成员，无访问限制
    成员声明;
    成员函数声明;

protected:  // 受保护成员，只能在本类以及其继承类和友元中访问
    成员声明;
    成员函数声明;

private:    // 私有成员，只能在本类以及友元中访问
    成员声明;
    成员函数声明;
};  // 注意分号
```

* 聚合类(aggregate class)
    * 满足以下所有条件：
        * 所有成员都是 `public` 的
        * 没有定义任何构造函数
        * 没有类内初始值
        * 没有基类，也没有 `virtual` 函数
    * 聚合类可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致
    * **聚合类可以当作C语言的结构体**

### 类访问控制

* 访问控制
    * `class` ：定义类默认 `private`
    * `struct` ：定义类默认 `public`
    * 作用域直到下一个访问控制说明符
    * `public` ：公有成员，无访问限制，提供类的接口
    * `protected` ：受保护成员，只能在本类以及其继承类和友元中访问
    * `private` ：私有成员，只能在本类以及友元中访问，提供实现细节
<br>

* 友元 `friend`
    * 友元允许特定的**非成员函数**访问一个类的**私有成员**.
    * 通常将友元声明成组地放在**类定义的开始或者结尾**
    * 声明友元的函数或类必须在外层作用域先声明或定义在外层作用域内
    * 类内部(放在私有或公有部分都行)声明函数前加关键字 `friend` 成为友元函数(定义时不用再加)
    * 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员

### 类成员

* 类成员
    * 类成员可以如下访问 `类对象名.类成员名` 或 `类对象指针->类成员名` 或 `类名::类静态成员名`
    * 必须在类的内部声明，不能在其他地方增加成员
    * 成员可以是变量，函数，类型别名
    * `mutable`
        * 存储说明符 `mutable` 特别说明这个成员是可变数据成员
        * 在**常量成员函数**中，可以更新 `mutable` 修饰的类的成员
<br>

* 类成员函数
    * 成员函数的**声明**必须在类的内部
    * 成员函数的**定义**既可以在类的内部也可以在外部
        * 在外部定义成员函数：`返回类型 类名::函数名(参数列表) {实现方法}`
    * 对于类的每一个成员函数，必须要有一个实现
    * 成员函数中不必显式引用对象即可使用成员的名字
    * `this`
        * 每个成员函数都有一个额外的，隐含的形参 `this`
        * `this` 总是指向当前对象，因此 `this` 是一个常量指针(不是指向常量的指针)
        * `return *this;` 可以让成员函数连续调用，此时成员函数的返回类型是**类的引用**
    * `inline`
        * 在类内部定义成员函数，默认是内联函数 `inline`
        * 在类外部定义的成员函数，也可以在类中声明时显式地加上 `inline`，表示内联
    * `const`
        * 形参表后面的 `const`，表明是**常量成员函数**，即 `this` 指向的当前对象是常量
        * 定义方法：`返回类型 类名::函数名(参数列表) const {实现方法}`
        * const对象和非const对象都能调用const成员函数，非const对象只能调用非const成员函数
    * `virtual`
        * 虚函数：基类中的成员函数声明前面加 `virtual`，派生类中重写的 `virtual` 函数自动成为虚函数
        * 派生类中重写要求函数的特征标志(包括参数的数目、类型和顺序)必须与基类中的函数一致
        * 虚函数的使用将导致类对象占用更大的内存空间
            * 编译器给每一个包括虚函数的对象添加了一个隐藏成员：指向虚函数表的指针
            * 虚函数表(virtual function table)包含了虚函数的地址，由所有虚函数对象共享
            * 当派生类重新定义虚函数时，则将该函数的地址添加到虚函数表中
            * 无论一个类对象中定义了多少个虚函数，虚函数表指针只有一个
<br>

* `static`
    * `static` 用于声明而不是定义，表示静态成员
    * 非`static`数据成员存在于类类型的每个对象中
    * `static`数据成员独立于该类的任意对象存在
    * 每个`static`数据成员是与类关联的对象，并不与该类的对象相关联
    * 访问：`类名::静态成员` 或 `类实例名.静态成员`
    * 外部定义类的静态成员函数，声明加定义不用再加 `static`
    * 静态数据成员通常不在类的内部初始化，而是在类外部定义时进行初始化
        * 如果一定要在类内部定义，则要求必须是字面值常量类型的 `constexpr`
    * 类的静态成员函数不能声明为 `const`, 不能调用 `this` 指针
    * 可以使用静态成员做默认实参

### 构造和析构函数

**一定特别注意构造虚构函数中对成员的访问，访问的时候对象的成员可能未初始化或已销毁**。例如以下未定义行为：**1. 构造函数创建线程，线程中访问本对象**；**2. 析构函数获取本对象的智能指针** 。

* 特殊成员函数(构造函数、析构函数、拷贝操作、移动操作)
    * `MyClass()` ：默认构造函数
        * 不带任何参数，构造函数没有返回类型，连 `void` 也没有
        * 类中未声明任何构造函数(包括拷贝/移动构造)时生成
        * 若声明其他构造函数(如有参构造)，需显式用 `=default` 声明默认构造
        * 含常量成员或引用成员时，编译器生成的默认构造无法初始化它们，需显式定义有参构造
        * 含类类型成员时，其默认构造函数会被自动调用
    * `MyClass(参数列表)` ：有参构造函数
        * 定义：`类名::和类名相同的函数名(参数列表) : 成员名{值},成员名{值} {实现方法}`
        * `: 成员名{值},成员名{值}` 是初始化列表，冒号开头，逗号隔开，小括号或花括号包围值(不是必需的)
        * 初始化列表执行顺序与成员变量在类中声明顺序相同，与初始化列表中语句书写先后无关(不按顺序写有编译警告)
        * 相对于在构造函数中赋值，初始化列表执行效率更高
        * 如果一个构造函数为所有参数都提供了默认参数，那么它实际上也定义了默认的构造函数
        * 必须对任何 `const` 或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式
    * `~MyClass()` ：析构函数
        * 定义：`类名::~和类名相同的函数名() {实现方法}`
        * 析构函数名是类型名前加`~`，不接受参数，不可重载，类对象退出作用域时被自动调用释放类的资源
        * 先执行自身的函数体，再调用成员的析构函数，再调用基类的析构函数
        * 未显式声明析构函数时自动生成
        * 虚基类析构函数可声明为virtual以支持多态
    * `MyClass(const MyClass&)` ：拷贝构造函数
        * 未显式声明拷贝构造、移动操作(构造/赋值)或析构函数时生成
        * 默认执行浅拷贝，含指针/资源的类需重写以实现深拷贝
        * 拷贝定义
            * 拷贝目标Y和源X需要满足2个准则：
                * 不变性： `X==Y`
                * 独立性： 改变某个对象不影响另一个对象
                * 如果不满足独立性，则拷贝是**浅拷贝**，否则是**深拷贝**
    * `MyClass& operator=(const MyClass&)` ：拷贝赋值运算符
        * 未显式声明拷贝赋值、移动操作(构造/赋值)或析构函数时生成
    * `MyClass(MyClass&&)` ：移动构造函数
        * 未显式声明任何拷贝操作、移动操作或析构函数时生成(C++11起)
        * 默认对成员逐成员移动(支持移动的成员移动，否则拷贝)
    * `MyClass& operator=(MyClass&&)` ：移动赋值运算符
        * 未显式声明任何拷贝操作、移动操作或析构函数时生成(C++11起)
        * 默认对成员逐成员移动(支持移动的成员移动，否则拷贝)
    * 委托构造函数 (C++11)
        * 委托构造函数将自己的职责委托给了其他构造函数
        * 例子  `A(): A("", 0, 0) {}`
    * 继承构造函数 (C++11)
        * 继承构造函数将直接继承基类的构造函数
        * 例子
        ```cxx
        class Sub : public Base {
        public:
            using Base::Base; // 继承构造
        };
        ```

* 构造赋值生成规则
    * 控制默认生成和删除
        * `=default` (C++11)
            * 显式缺省(告知编译器生成函数默认的缺省版本)
            * 默认函数需要用于特殊的成员函数(默认构造函数，拷贝构造函数，析构函数、赋值运算等)
            * 例子 `A() = default;` 其他写法 `A() {}`
        * `=delete` (C++11)
            * 显式删除(告知编译器不生成函数默认的缺省版本)
            * 要求编译器删除某类构造函数，一般用于禁用拷贝构造和拷贝赋值函数(禁用参数转换构造)
            * 例子 `A(const A&) = delete;` `A& operator=(const A&) = delete;`
    * 默认生成规则
        * 声明任一拷贝操作会阻止移动操作的默认生成
        * 声明析构函数会阻止移动操作的生成，但不影响拷贝操作
        * 声明任一移动操作会同时阻止拷贝操作和移动操作的默认生成。
    * 三五法则(Rule of Three/Five/Zero)
        * 规则三：若自定义析构函数、拷贝构造或拷贝赋值中的任一，需定义全部三者(避免资源泄漏)
        * 规则五(C++11)：增加移动构造和移动赋值，共五个函数
        * 规则零：不声明任何特殊函数，依赖编译器默认行为(适用于无资源管理的简单类)
    * 控制隐式转换
        * `explicit`
            * 如果构造函数**只接受一个实参**(C++11支持`explicit` 用于多个形参)，则它实际上定义了转换为此类类型的**隐式转换机制**，这种构造函数又叫**转换构造函数**
            * `explicit` 出现在类构造函数声明前，表示禁止隐式转换，类构造函数只能直接初始化
            * `={初始化列表}` 和 `=值` 的方式可能是隐式转换
            * `explicit` 用在函数声明中，而不能用在函数定义中

    ```cxx
    class MyClass {
        MyClass() = default; // 编译器生成默认的默认构造函数
        MyClass(const MyClass&) = delete; // 删除复制构造函数
        MyClass(MyClass&&) { 移动逻辑实现 }; // 移动构造函数实现
        MyClass& operator=(const MyClass&) = delete; // 删除复制赋值运算符
        MyClass& operator=(MyClass&&) { 移动逻辑实现 } ; // 移动赋值运算符函数实现
    };
    ```

    ```cxx
    class Test
    {
    public :
        explicit Test2(int num): n{num} {}
    private:
        int n;
    };
    int main()
    {
        Test t1 = 12;   // 有explicit，编译报错
        Test t2(13);    // 直接初始化
        return 0;
    }
    ```

### 运算符重载

* 定义： `返回类型 operator运算符(参数列表) {实现方法}`
* 不可以重载
    ```cxx
    ::      .       .*      ?:
    sizeof  alignof typeid
    ```
* 前置 `T& operator++();` 后置 `T operator++(int);`, int称为哑参数，只作区分前置和后置作用

### 继承

```cxx
class derived-class: access-specifier base-class {class_definition};
```

* 继承允许我们依据另一个类来定义一个类，指向派生类的指针可隐式转换为指向基类的指针
    * class derived-class：派生类
    * access-specifier：基类访问修饰符 `public` `protected` `private`
        * 如果未使用访问修饰符 access-specifier，则默认为 private
    * base-class：基类名
    * 多个基类可以使用逗号隔开，例如 `class MyClass: public BaseA, private BaseB { class_definition };`
    * 一个派生类继承了所有的基类方法，但下列情况除外：
        * 基类的构造函数、析构函数
        * 基类的重载运算符
        * 基类的友元函数
<br>

* 继承类型
    * 公有继承(public)：
        * 基类的公有成员也是派生类的公有成员
        * 基类的保护成员也是派生类的保护成员
        * 基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问
    * 保护继承(protected)
        * 基类的公有和保护成员将成为派生类的保护成员
    * 私有继承(private)
        * 基类的公有和保护成员将成为派生类的私有成员
    * `using 基类::可访问的基类成员;` ：修改默认继承的保护属性，声明的位置决定新权限：
        * 在 `public:` 下声明 → 成员在派生类中变为 public
        * 在 `protected:` 下声明 → 成员在派生类中变为 protected
<br>

* 多继承(Multiple Inheritance)
    * 多继承是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员
    * `class derived-class: access-specifier1 base-class1, access-specifier2 base-class2`
* 虚继承(Virtual Inheritance)
    * 格式：`class 类名: virtual 继承方式 父类名`
    * 环状继承 `A->D, B->D, C->(A，B)`，这个继承会使D创建两个对象，要解决上面问题就要用虚继承格式
        * 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类
        * 其中，这个被共享的基类就称为虚基类(Virtual Base Class)
        * 在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员
        * 在通过继承类对象访问虚基类对象中的成员时，都必须通过某种间接引用来完成，这样会增加引用寻址时间(就和虚函数一样)
<br>

* `final` (C++11)
    * 阻止从类继承：将类标记为final，方法时直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误
        * `class Super final { };`
    * 阻止重写虚函数：将方法标记为final，这意味着无法在子类中重写该方法。这时final关键字置于方法参数列表后面
        * `virtual void SomeMethod() final;`
<br>

### 虚函数

* 纯虚函数，继承的是接口(interface)，必须在派生类中重写该函数的实现
    * `virtual void Eat() const = 0;`
    * 派生类要想使用基类缺省的实现，必须显式的调用，须加上类作用域操作符 `::`
    * 纯虚函数不重写是不能实例化继承类的
    * 具有纯虚函数的类称为抽象类，无法创建抽象类的对象，抽象类通常没有构造函数
* 普通虚函数，继承的是：接口 + 缺省实现(default implementation)，由派生类自行选择是否重写该函数
    * `virtual void Say(const std::string& msg);`
    * 基类的虚函数指针没有被派生类覆盖
    * 虚函数是动态绑定的，通过实例调用的函数取决于它**实际的指针**
* 非虚函数
    * 非虚函数继承的是：接口 + 强制实现(mandatory implementation)，在派生类中，无须重新定义继承自基类的成员函数
    * `int Name() const;`
    * 如果在派生类中重新定义了继承自基类的成员函数，派生类中重新定义的成员函数会**隐藏**继承自基类的成员函数
    * 不要重新定义一个继承自基类的非虚函数
    * 非虚函数是 静态绑定的，通过实例调用的函数取决于它**声明的指针**
<br>

* `override` ：重写(C++11)
    * 公有继承包含两部分：一是“接口”(interface)，二是 "实现"(implementation)
    * 在派生类中，重写(override) 继承自基类成员函数的实现(implementation) 时，要满足如下条件：
        * 一虚：基类中，成员函数声明为虚拟的(virtual)
        * 二容：基类和派生类中，成员函数的返回类型和异常规格(exception specification) 必须兼容
        * 四同：基类和派生类中，成员函数名、形参类型、常量属性(constness) 和 引用限定符(reference qualifier) 必须完全相同
    * 如果派生类在虚函数声明时使用了 `override` 关键字，那么该函数必须重写其基类中的同名函数，否则代码将无法通过编译
        * `virtual void Eat() override;` 说明符 `const noexcept final override ` 中 `override` 必须放在最后
    * 覆盖注意点：
        * 覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果
        * 覆盖的方法的返回值必须和被覆盖的方法的返回一致
        * 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类
        * 被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖
<br>

* 重载、覆盖、隐藏的区别:
    * 成员函数被重载的特征(运行看参数)
        * 相同的范围(在同一个类中)
        * 函数名字相同
        * 参数不同
        * virtual关键字可有可无
    * “覆盖”是指派生类函数覆盖基类函数(运行调用派生类)，特征是：
        * 不同的范围(分别位于派生类与基类)
        * 函数名字相同
        * 参数相同
        * 基类函数必须有virtual关键字
    * “隐藏”是指派生类的函数屏蔽了与其同名的基类函数(运行用什么就调用什么)，特征是：
        * 如果派生类的函数与基类的函数同名，但是参数不同，此时，不论有无virtual关键字，基类的函数将被隐藏(注意别与重载混淆)
        * 如果派生类的函数与基类的函数同名，但是参数相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏(注意别与覆盖混淆)

## 线程与同步(C11)

* 头文件为 `threads.h` 。

### 线程(thrd)

* `thrd_create` ：创建线程

    ```c
    /**
     * @brief   创建线程
     * @param   thr [OUT] 保存线程ID
     * @param   func [IN] 线程函数指针
     * @param   arg [IN] 传给线程函数的值
     * @return  成功返回thrd_success；失败返回其它值
     * @note    无
     */
    enum {
        thrd_success  = 0,  // 成功
        thrd_busy     = 1,  // 资源暂时不可用
        thrd_error    = 2,  // 其它错误
        thrd_nomem    = 3,  // 内存耗尽
        thrd_timedout = 4   // 时间用尽
    };
    typedef int(*thrd_start_t)(void*);
    int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);
    ```

* `thrd_exit` ：线程退出

    ```c
    /**
     * @brief   线程退出
     * @param   res [IN] 线程退出设置的结果码
     * @return  无返回值
     * @note    thrd_exit 函数终止调用方线程的执行，并设置其结果码为 res
     */
    void thrd_exit(int res);
    ```

* `thrd_detach` ：分离线程

    ```c
    /**
     * @brief   分离线程
     * @param   thr [IN] 线程ID
     * @return  成功返回thrd_success；失败返回thrd_error
     * @note    将thr所标识的线程从当前环境中分离，一旦该线程退出，就自动释放其保有的资源
     */
    int thrd_detach(thrd_t thr);
    ```

* `thrd_join` ：阻塞到线程终止为止

    ```c
    /**
     * @brief   阻塞到线程终止为止
     * @param   thr [IN] 线程ID
     * @param   res [OUT] 线程退出设置的结果码，可以为NULL
     * @return  成功返回thrd_success；失败返回thrd_error
     * @note    1. 阻塞当前线程，直到 thr 所标识的线程完成执行
     *          2. detach和join只能调用其中一个，都未调用会造成资源泄漏，都调用则行为未定义
     */
    int thrd_join(thrd_t thr, int *res);
    ```

* `thrd_sleep` ：线程延时

    ```c
    /**
     * @brief   线程延时
     * @param   duration [IN] 要休眠的时长
     * @param   remaining [OUT] 信号提前唤醒时存储剩余时长，可以为NULL
     * @return  成功返回0；失败返回-1
     * @note    阻塞当前线程的执行，至少直至经过 duration 所指向的时长
     */
    int thrd_sleep(const struct timespec* duration, struct timespec* remaining);
    ```

* `thrd_yield` ：线程让出CPU

    ```c
    /**
     * @brief   分离线程
     * @param   无参数
     * @return  无返回值
     * @note    yield和sleep的区别
     *          1. yield让出CPU后仍可能立即返回并继续执行原进程，不会进入阻塞状态
     *          2. sleep使线程进入阻塞状态，直到指定时间结束或被信号唤醒
     */
    void thrd_yield(void);
    ```

* `thrd_current` ：获取当前线程ID

    ```c
    /**
     * @brief   获取当前线程ID
     * @param   无参数
     * @return  返回线程ID
     * @note    无
     */
    thrd_t thrd_current(void);
    ```

* `thrd_equal` ：比较线程ID

    ```c
    /**
     * @brief   比较线程ID
     * @param   lhs [IN] 线程ID1
     * @param   rhs [IN] 线程ID2
     * @return  相等返回非0；不等返回0
     * @note    无
     */
    int thrd_equal(thrd_t lhs, thrd_t rhs);
    ```

### 互斥锁(mtx)

* `mtx_init` ：初始化互斥锁

    ```c
    /**
     * @brief   初始化互斥锁
     * @param   mutex [OUT] 保存锁句柄
     * @param   type [IN] 互斥的类型
     * @return  成功返回thrd_success；失败返回thrd_error
     * @note    四种锁组合：`plain` `recursive` `timed` `recursive|timed`
     */
    enum {
        mtx_plain = 0,      // 非递归
        mtx_recursive = 1,  // 递归
        mtx_timed = 2       // 支持超时
    };
    int mtx_init(mtx_t* mutex, int type);
    ```

* `mtx_destroy` ：反初始化互斥锁
    ```c
    /**
     * @brief   反初始化互斥锁
     * @param   mutex [IN] 锁句柄
     * @return  无返回值
     * @note    无
     */
    void mtx_destroy(mtx_t *mutex);
    ```

* `mtx_lock` ：加锁
    ```c
    /**
     * @brief   加锁
     * @param   mutex [IN] 锁句柄
     * @return  成功返回thrd_success；失败返回thrd_error
     * @note    阻塞当前线程，直至锁定 mutex 所指向的互斥体
     */
    int mtx_lock(mtx_t* mutex);
    ```

* `mtx_trylock` ：尝试加锁
    ```c
    /**
     * @brief   尝试加锁
     * @param   mutex [IN] 锁句柄
     * @return  成功返回thrd_success；失败返回thrd_error或thrd_busy(已被其他线程锁定)
     * @note    尝试锁定 mutex 所指向的互斥而不阻塞，若该互斥已被锁定则立即返回
     */
    int mtx_trylock(mtx_t* mutex);
    ```

* `mtx_timedlock` ：带超时的加锁
    ```c
    /**
     * @brief   带超时的加锁
     * @param   mutex [IN] 锁句柄
     * @param   time_point [IN] 指向要等待到超时的绝对日历时间的指针
     * @return  成功返回thrd_success；失败返回thrd_error或thrd_timedout(超时)
     * @note    阻塞当前线程，直到 mutex 所指向的互斥体被锁，或直到抵达 time_point 所指向的基于 TIME_UTC 的时间点
     */
    int mtx_timedlock(mtx_t* mutex, const struct timespec* time_point);
    ```

* `mtx_unlock` ：解锁
    ```c
    /**
     * @brief   解锁
     * @param   mutex [IN] 锁句柄
     * @return  成功返回thrd_success；失败返回thrd_error
     * @note    无
     */
    int mtx_unlock(mtx_t* mutex);
    ```

### 条件变量(cnd)

* `cnd_init` ：初始化条件变量

    ```c
    /**
     * @brief   初始化条件变量
     * @param   cond [OUT] 保存条件变量句柄
     * @return  成功返回thrd_success；失败返回thrd_error或thrd_nomem(内存不足)
     * @note    无
     */
    int cnd_init(cnd_t* cond);
    ```

* `cnd_destroy` ：反初始化条件变量
    ```c
    /**
     * @brief   反初始化条件变量
     * @param   cond [IN] 条件变量句柄
     * @return  无返回值
     * @note    若有线程在 cond 上等待，则行为未定义
     */
    void cnd_destroy(cnd_t *cond);
    ```

* `cnd_wait` ：等待通知
    ```c
    /**
     * @brief   等待
     * @param   cond [IN] 条件变量句柄
     * @param   mutex [IN] 互斥锁句柄
     * @return  成功返回thrd_success；失败返回thrd_error
     * @note    1. 原子地解锁 mutex 所指向的互斥体，并在 cond 所指向的条件变量上阻塞
     *          2. 阻塞直至线程被 cnd_signal 或 cnd_broadcast 发信号，或直至虚假唤醒出现
     *          3. 在此函数返回前，重新锁定该互斥体
     */
    int cnd_wait(cnd_t* cond, mtx_t* mutex);
    ```

* `cnd_timedlock` ：带超时的等待
    ```c
    /**
     * @brief   带超时的等待
     * @param   cond [IN] 条件变量句柄
     * @param   mutex [IN] 互斥锁句柄
     * @param   time_point [IN] 指向要等待到超时的绝对日历时间的指针
     * @return  成功返回thrd_success；失败返回thrd_error或thrd_timedout(超时)
     * @note    带超时的等待，直到抵达 time_point 所指向的基于 TIME_UTC 的时间点
     */
    int cnd_timedlock(cnd_t* cond, mtx_t* mutex, const struct timespec* time_point);
    ```

* `cnd_signal` ：唤醒一个等待
    ```c
    /**
     * @brief   唤醒一个等待
     * @param   cond [IN] 条件变量句柄
     * @return  成功返回thrd_success；失败返回thrd_error
     * @note    1. 解除当前在 cond 所指向的条件变量上等待的一个线程的阻塞
     *          2. 若无线程被阻塞，则不做任何事并返回 thrd_success
     */
    int cnd_signal(cnd_t* cond);
    ```

* `cnd_broadcast` ：唤醒所有等待
    ```c
    /**
     * @brief   唤醒所有等待
     * @param   cond [IN] 条件变量句柄
     * @return  成功返回thrd_success；失败返回thrd_error
     * @note    1. 解除当前在 cond 所指向的条件变量上等待的所有线程的阻塞
     *          2. 若无线程被阻塞，则不做任何事并返回 thrd_success
     */
    int cnd_broadcast(cnd_t* cond);
    ```

### 原子操作(atomic)

* 原子操作(atomic)
    * `typedef _Atomic T AT;` ： T为基础类型，AT为对应的原子类型(是volatile的)
    * memory_order内存序说明见C++的原子量
    * 不带 `_explicit` 的函数默认内存序是 `memory_order_seq_cst` (强一致性需求)，性能最低
    * `compare_exchange` 的参数
        * `succ` 读修改写操作的内存同步顺序，容许所有值
        * `fail` 加载操作的内存同步顺序，不能为 `release` 或 `acq_rel` 且不能指定强于succ的顺序
```c
include <atomic>

typedef enum {
    memory_order_relaxed = __ATOMIC_RELAXED,
    memory_order_consume = __ATOMIC_CONSUME,
    memory_order_acquire = __ATOMIC_ACQUIRE,
    memory_order_release = __ATOMIC_RELEASE,
    memory_order_acq_rel = __ATOMIC_ACQ_REL,
    memory_order_seq_cst = __ATOMIC_SEQ_CST
} memory_order;

void atomic_init(AT* obj, T desired);   // 初始化原子量为特定值
T atomic_load(const AT* obj);           // 原子读取当前值并返回
T atomic_load_explicit(const AT* obj, memory_order order);
void atomic_store(AT* obj , T desired); // 原子写入新值
void atomic_store_explicit(AT* obj, T desired, memory_order order);
T atomic_exchange(AT* obj, T desired);  // 原子交换并返回旧值

T atomic_exchange_explicit(AT* obj, T desired, memory_order order);
T atomic_fetch_add(AT* obj, M arg);     // 原子加并返回旧值(arg为改变值)
T atomic_fetch_add_explicit(AT* obj, M arg, memory_order order);
T atomic_fetch_sub(AT* obj, M arg);     // 原子减并返回旧值
T atomic_fetch_sub_explicit(AT* obj, M arg, memory_order order);
T atomic_fetch_and(AT* obj, M arg);     // 原子与并返回旧值
T atomic_fetch_and_explicit(AT* obj, M arg, memory_order order);
T atomic_fetch_xor(AT* obj, M arg);     // 原子异或并返回旧值
T atomic_fetch_xor_explicit(AT* obj, M arg, memory_order order);
T atomic_fetch_or(AT* obj, M arg);      // 原子或并返回旧值
T atomic_fetch_or_explicit(AT* obj, M arg, memory_order order);

bool atomic_compare_exchange_weak(      // 原子条件交换并返回是否交换，等于expected时设置为desired
    AT *obj, T* expected, T desired);   // 可能伪失败(需循环重试)
bool atomic_compare_exchange_weak_explicit(AT *obj, T* expected,
    T desired, memory_order succ, memory_order fail);
bool atomic_compare_exchange_strong(    // 原子条件交换并返回是否交换，等于expected时设置为desired
    AT* obj, T* expected, T desired);   // 保证严格成功(性能略低)
bool atomic_compare_exchange_strong_explicit(AT* obj, T* expected,
    T desired, memory_order succ, memory_order fail);
```

## 线程与同步(C++)

### 线程(std::thread/std::jthread)

```cxx
template<class F, class... Args>
explicit thread(F&& f, Args&&... args); (C++11)

template<class F, class... Args>
explicit jthread(F&& f, Args&&... args); (C++20)
```

* 基本创建方式
    * 支持函数指针、函数对象(`std::function`)、Lambda表达式
    * `thread` 和 `jthread` 接口完全一致，唯一区别是：
        * `thread` 若未 `join` 或 `detach` ，析构时触发 `std::terminate`
        * `jthread` 若未 `join` 或 `detach` ，析构时自动 `join`
    ```cxx
    #include <thread>

    /* 线程局部存储，各线程独立，每个线程拥有独立变量副本 */
    thread_local int local_counter = 0;

    void task(int id) {
        /* ... */
    }

    int main() {
        /* 方式1：函数指针 + 参数传递 */
        std::thread t1(task, 1);
        t1.detach(); // 分离线程使其后台运行(不阻塞)

        /* 方式2：Lambda捕获局部变量 */
        int x = 42;
        std::thread t2([&x] { std::cout << x; });
        t2.join();   // 阻塞当前线程直至目标线程结束
    }
    ```
<br>

* 参数传递：默认值传递，引用传递需显式使用 `std::ref`
    ```cxx
    void update(int& val) { val = 100; }
    int data;
    std::thread t(update, std::ref(data)); // 传递引用
    ```
* 移动语义：支持线程对象所有权转移
    ```cxx
    std::thread t1([]{});
    std::thread t2 = std::move(t1); // t1失效，t2接管线程
    ```
* 获取线程ID
    ```cxx
    std::thread::id id = t.get_id();           // 线程对象ID
    auto this_id = std::this_thread::get_id(); // 当前线程ID
    ```
* 线程控制：
    * 纳秒 `nanoseconds` 、微秒 `microseconds` 、毫秒 `milliseconds` 、秒 `seconds`
    ```cxx
    std::this_thread::sleep_for(std::chrono::milliseconds(1)); // 休眠
    std::this_thread::yield(); // 主动让出CPU
    ```

### 期望(std::future/std::shared_future) (C++11)

`std::future` 只有一个实例能指代任何特定的异步结果， `std::shared_future` 可复制而且多个共享期望的对象能指代同一共享状态。

* `std::future` ：提供访问异步操作结果的机制：
    * 机制
        * 通过 `std::async` `std::packaged_task` 或 `std::promise` 创建的异步操作
          能提供一个 `std::future` 对象给该异步操作的创建者
        * 然后，异步操作的创建者可以使用多个方法查询、等待或从 std::future 提取值
        * 若异步操作尚未提供值，则这些方法可能阻塞
        * 当异步操作准备好发送结果给创建者时，它可以修改与创建者的 std::future 相链接的共享状态
    * 接口
        * `get()` ：阻塞获取结果(仅能调用一次)
            * 若任务抛出异常，调用 `get()` 时会重新抛出该异常
            * `std::future` 调用一次get后失效，使用 `std::shared_future` 可多次调用 `get()`
        * `wait()` ：阻塞仅等待完成
            * 使用 `wait_for()` 或 `wait_until()` 防止无限阻塞
        * `wait_for(duration)` ：限时等待，返回状态( `future_status::ready/timeout/deferred` )
            * `deferred` ：共享状态包含一个使用惰性求值的延迟函数，仅在明确请求时才计算其结果
        * `wait_until(time_point)` ：等待到指定时间点
        * `valid()` ：检查是否关联有效共享状态，如未调用 `get()` 等返回true

```cxx
template<class F, class... Args>
std::future<F返回值类型> async(F&& f, Args&&... args); // 不指定策略为async | deferred
std::future<F返回值类型> async(std::launch policy, F&& f, Args&&... args);
```

* `std::async` ：启动异步任务并返回关联的 future
    * 异步执行函数 Fn，返回 `std::future<T>` 对象(T为函数返回值类型)
    * 执行策略(位掩码值)
        * `std::launch::async` ：立即启动，强制在新线程异步执行任务
            * 若策略为 `async` ，即使未调用 `get()` ，析构函数也会阻塞至任务完成
        * `std::launch::deferred` ：延迟执行，仅在调用 `get()` 或 `wait()` 时在当前线程同步执行
            * 若策略为 `deferred` 且未调用 `get()` / `wait()` ，任务永不执行，无资源开销
        * 未设置策略行为未定义，同时设置策略行为标准建议(但不要求)利用现有的并发资源，并且推迟另外的任务

    ```cxx
    #include <future>
    auto future = std::async(std::launch::async, []{
        return compute();
    });
    int result = future.get(); // 此时才执行任务，阻塞获取结果
    ```

* `std::promise` ：手动设置值
    * 通过promise设置值，future获取该值，适用于跨线程传递结果
    * promise销毁前需设置值，否则关联的 `future.get()` 抛出 `std::future_error`

    ```cxx
    std::promise<int> prom;
    std::future<int> fut = prom.get_future();
    std::thread t([&] {
        prom.set_value(100); // 设置值
    });
    std::cout << fut.get(); // 输出100
    t.join();
    ```

* `std::packaged_task` ：包装函数
    * 将可调用对象(函数、Lambda)与future绑定，封装函数及其结果，便于在线程池中调度

    ```cxx
    std::packaged_task<int()> task([]{ return 42; });
    std::future<int> fut = task.get_future();
    std::thread(std::move(task)).detach(); // 在新线程执行
    std::cout << fut.get(); // 输出42
    ```

### RAII接管锁

* RAII接管通过对象的构造和析构自动管理锁的生命周期，避免手动解锁导致的死锁或资源泄漏。

| 锁类型 | 底层互斥量 | 锁定模式 | 特性简述 |
| ------ | ---------- | -------- | -------- |
| `std::lock_guard` | `std::mutex 等独占锁` |  独占锁定 | 轻量、不可手动控制 |
| `std::unique_lock` | `std::mutex 等独占锁` |  独占锁定 | 灵活支持延迟锁定、条件变量 |
| `std::shared_lock` | `std::shared_mutex` | 共享锁定 | 允许多线程并发读操作 |

* `std::lock_guard`
    * 构造时立即锁定互斥量，析构时自动解锁
    * 不支持手动解锁、延迟锁定或移动语义，仅适用于当前作用域
    * 简单的临界区保护，无需中途解锁或复杂控制
* `std::unique_lock`
    * 构造时可选择锁定互斥量的加锁方式(锁定，不锁定 `std::defer_lock` ，尝试锁定 `std::try_lock` ，超时锁定)，析构时自动解锁
    * 支持手动解锁锁定 `unlock()` / `lock()`
    * 支持尝试锁定 `try_lock()`
    * 支持超时锁定 `try_lock_for(duration)` 和 `try_lock_until(time_point)`
    * 支持条件变量协作
    * 可移动但不可复制，适合需要转移锁所有权的场景
    * 需要灵活控制锁的粒度(如提前解锁减少阻塞)
* `std::shared_lock`
    * 专用于 `std::shared_mutex` ，允许多个线程同时获取共享锁(读锁)，写操作需通过 std::unique_lock 独占访问
    * 构造时可选择锁定互斥量的加锁方式和支持的接口同 `std::unique_lock`

### 基础互斥锁(std::mutex)

* `std::mutex` ：互斥锁
    * 互斥锁同一时刻仅允许一个线程持有锁，其他试图加锁的线程会被阻塞 `lock()` 或立即返回失败 `try_lock()`、
    * 禁止拷贝构造和赋值互斥锁，确保锁状态的唯一性
    * `std::lock_guard` 或 `std::unique_lock` ：优先使用自动加锁解锁
    * `lock()` `try_lock` `unlock()` ：手动加锁解锁 (try_lock加锁成功返回 true，失败返回 false)
    * `std::scoped_lock lock(mtx1, mtx2)` ：同时锁定多个锁，所有线程都是同样的顺序加锁(C++17)

```cxx
std::mutex mtx;
void safe_op() {
    std::lock_guard<std::mutex> lock(mtx); // RAII自动管理
    // 临界区操作
}
```

* `std::timed_mutex` ：超时互斥锁，新增两个关键方法：
    * `try_lock_for(duration)` ：在指定时间段内尝试获取锁，超时返回 false，若时长≤0，等价于 `try_lock()`
    * `try_lock_until(time_point)` ：在指定时间点前尝试获取锁，超时返回 false

```cxx
std::timed_mutex mtx;

auto waittime = std::chrono::milliseconds(10);
if (mtx.try_lock_for(waittime)) {
    // 临界区操作
    mtx.unlock();
}

auto deadline = std::chrono::steady_clock::now() + std::chrono::milliseconds(10); // 单调时间
if (mtx.try_lock_until(deadline)) {
    // 临界区操作
    mtx.unlock();
}

std::unique_lock<std::timed_mutex> lock(tmutex, std::defer_lock);
if (lock.try_lock_for(std::chrono::milliseconds(10))) {
    // 临界区
    // 自动解锁
}
```

### 递归锁(std::recursive_mutex)

* `std::recursive_mutex` ：递归锁
    * 允许同一线程重复加锁(而 `std::mutex` 重复加锁会造成死锁)
        * 首次调用 `lock()` 时，计数器置为1，线程获得锁；同一线程后续每次 `lock()` 增加计数器
        * 每次 `unlock()` 减少计数器；计数器归零时锁才真正释放
        * 计数器维护和线程 ID 检查导致性能低于 `std::mutex` ，常用于递归函数调用

```cxx
std::recursive_mutex rmtx;
void recursive_func() {
    rmtx.lock();
    rmtx.lock(); // 允许重复锁定
    rmtx.unlock();
    rmtx.unlock();
}
```

```cxx
std::recursive_mutex rmtx;
void recursive_print(int n) {
    std::lock_guard<std::recursive_mutex> lock(rmtx); // RAII 自动管理计数
    std::cout << "Level " << n << std::endl;
    if (n > 0) {
        recursive_print(n - 1); // 递归调用中再次加锁
    }
    // 析构时根据递归深度逐层解锁
}
```

* `std::recursive_timed_mutex` ：超时递归锁
    * 使用说明参考**超时互斥锁**

### 读写锁(std::shared_mutex)(C++14)

* `std::shared_mutex` ：读写锁
    * 多个线程可同时持有共享锁(用于读操作)，实现方式： `lock_shared()` 或 `std::shared_lock`
    * 仅一个线程可持有独占锁(用于写操作)，实现方式： `lock()` 或 `std::unique_lock`
        * 无任何锁时，写线程才能获取锁，且会阻塞所有读写线程

```cxx
std::shared_mutex rwmtx;

void read_data() {
    std::shared_lock lock(rwmtx); // 共享锁(允许多读)
}
void write_data() {
    std::unique_lock lock(rwmtx); // 独占锁(写互斥)
}
```

```cxx
std::shared_mutex rwmtx;
void read_data() {
    rwmtx.lock_shared();
    // 读操作(允许多读)
    rwmtx.unlock_shared();
}
void write_data() {
    rwmtx.lock();
    // 写操作(写互斥)
    rwmtx.unlock();
}
```

* `std::shared_timed_mutex` ：超时读写锁
    * 使用说明参考**超时互斥锁**
    * 共享锁超时
        * `try_lock_shared_for(duration)` ：相对时间内尝试获取读锁
        * `try_lock_shared_until(time_point)` ：绝对时间点前尝试获取读锁
    * 独占锁超时
        * `try_lock_for(duration)` ：相对时间内尝试获取写锁
        * `try_lock_until(time_point)` ：绝对时间点前尝试获取写锁

### 条件变量(std::condition_variable)

* `std::condition_variable` ：条件变量
    * 等待条件：线程获取互斥锁后调用 `wait()` ，原子性地释放锁并阻塞，直至被其他线程唤醒，唤醒后重新获取锁并验证条件
        * `wait(unique_lock<mutex>& lock)` ：阻塞至收到通知，唤醒后重新获取锁
        * `wait(unique_lock<mutex>& lock, Predicate pred)` ：阻塞直至收到通知且 `pred()` 返回 true，避免虚假唤醒
        * `wait_for(unique_lock<mutex>& lock, Duration rel_time, Predicate pred)` ：在指定相对时间内等待条件成立，超时返回 false
        * `wait_until(unique_lock<mutex>& lock, TimePoint abs_time, Predicate pred)` ：在指定绝对时间点前等待条件成立，超时返回 false
    * 通知条件：另一线程修改共享状态后，调用 `notify_xxx()` 唤醒等待线程
        * `notify_one()` ：唤醒一个等待线程(唤醒顺序不确定)
        * `notify_all()` ：唤醒所有等待线程，适用于多消费者场景

```cxx
std::mutex mtx;
std::condition_variable cv;
std::queue<int> data_queue;

void producer() {
    std::lock_guard<std::mutex> lock(mtx);
    data_queue.push(42);
    cv.notify_one(); // 通知一个消费者
}

void consumer() {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return !data_queue.empty(); }); // 等价于 `while (!data_queue.empty()) cv.wait(lock);`
    int data = data_queue.front();
    data_queue.pop();
}
```

### 信号量(std::counting_semaphore/std::binary_semaphore)(C++20)

* `std::counting_semaphore` ：信号量
    * 信号量可本线程加锁，其它线程解锁(互斥锁只能本线程解锁本线程的加锁)
    * 信号量使用内部计数器：表示当前可用的资源许可数量，初始值由构造函数设定
    * 获取许可
        * `acquire()` ：获取许可
            * 计数器 > 0 时：原子减 1，线程继续执行
            * 计数器 = 0 时：线程阻塞，直到其它线程释放许可
        * `try_acquire()` ：尝试非阻塞获取许可，成功返回true
        * `try_acquire_for(duration)` ：在指定时间内尝试获取许可，超时返回false
        * `try_acquire_until(time_point)` ：在指定时间点前尝试获取许可，超时返回false
    * 释放许可
        * `release(count = 1)` ：释放许可，计数器原子加count(默认值1)，唤醒一个或多个阻塞线程(唤醒顺序不确定)
* `std::binary_semaphore` ：单值信号量
    * `using binary_semaphore = std::counting_semaphore<1>;` 只有一个资源的信号量

```cxx
std::counting_semaphore<10> sem(3); // 最大值10，初始值3，最多运行10线程同时访问
void access_resource() {
    sem.acquire(); // 获取信号量
    // 使用资源
    sem.release(); // 释放信号量
}
```

### 屏障(std::barrier)(C++20)

* `std::barrier` ：屏障
    * 用于协调多个线程在特定执行点同步等待，直到所有参与者到达后继续执行
    * `arrive(update=1)` ：通知屏障线程已到达，计数器减少update值，返回arrival_token用于后续等待
    * `wait(arrival_token)` ：阻塞当前线程，直到当前阶段完成(计数器归零)
    * `arrive_and_wait()` ：最常用，原子性减少计数器并阻塞，直到所有线程到达(等价于 arrive(1) + wait)
    * `arrive_and_drop()` ：减少当前阶段计数器，并永久减少后续阶段的初始计数值(线程退出时调用)

```cxx
std::barrier sync(4); // 4个线程
void worker() {
    process_stage1();    // 阶段1独立计算
    sync.arrive_and_wait(); // 同步等待
    process_stage2();    // 阶段2依赖阶段1结果
}
```

```cxx
std::barrier sync(4); // 4个线程
void worker(int id) {
    while (!done) {
        compute();
        if (should_exit(id)) {
            sync.arrive_and_drop(); // 退出并减少后续计数
            return;
        }
        sync.arrive_and_wait();  // 正常同步
    }
}
```

### 原子量(std::atomic)

对原子变量的操作(读/写/修改)是不可分割的，执行过程中不会被线程调度打断，底层通过CPU原子指令实现，无需锁机制。

* 核心操作

| 操作       | 函数                                              | 说明                   |
|------------|-------------------------------------------------- |----------------------- |
| 原子读取   | `load(可选内存序)`                                | 原子读取当前值并返回   |
| 原子写入   | `store(新值,可选内存序)`                          | 原子写入新值，无返回值 |
| 原子交换   | `exchange(新值,可选内存序)`                       | 原子交换并返回旧值     |
| 原子加法   | `fetch_add(加的值,可选内存序)`                    | 原子加并返回旧值       |
| 原子减法   | `fetch_sub(减的值,可选内存序)`                    | 原子减并返回旧值       |
| 原子位与   | `fetch_and(与的值,可选内存序)`                    | 原子按位与并返回旧值   |
| 原子位异或 | `fetch_xor(异或的值,可选内存序)`                  | 原子按位异或并返回旧值 |
| 原子位或   | `fetch_and(或的值,可选内存序)`                    | 原子按位或并返回旧值   |
| 比较并交换 | `compare_exchange_weak(比较值,新值,可选succ内存序,可选fail内存序)`   | 原子条件交换并返回是否交换<br>可能伪失败(需循环重试) |
| 比较并交换 | `compare_exchange_strong(比较值,新值,可选succ内存序,可选fail内存序)` | 原子条件交换并返回是否交换<br>保证严格成功(性能略低) |

* 注1：compare_exchange中，`succ` 是读修改写操作的内存同步顺序，容许所有值； `fail` 是加载操作的内存同步顺序，不能为 `release` 或 `acq_rel` 且不能指定强于succ的顺序
* 注2：新增 `wait(比较值,可选内存序)` ，阻塞到值不等于比较值或被 `notify_one()` 或 `notify_all()` 唤醒，或线程被虚假解除锁定(C++20)

```cxx
std::atomic<int> counter(0);
void increment() {
    counter.fetch_add(1, std::memory_order_relaxed); // 无内存序约束
}
```

```cxx
std::atomic<Node*> head;
void push(int val) {
    Node* new_node = new Node{val};
    new_node->next = head.load(std::memory_order_relaxed);
    while(!head.compare_exchange_weak(new_node->next, new_node));
}
```

* 内存模型详解

| 内存序                 | 性能 | 适用操作     | 核心特性和重排序约束                          |
| ---------------------- | ---- | ------------ | --------------------------------------------  |
| `memory_order_relaxed` | 最高 | 计数器       | 仅保证原子性，无顺序约束；允许任意指令重排    |
| `memory_order_consume` | 高   | 已废弃       | 限制依赖操作重排(仅对数据依赖链有效) ，仅保证依赖当前加载值的操作不重排到加载前 |
| `memory_order_acquire` | 高   | 加载         | 阻止后续操作前移(Load-Load,Load-Store不重排到Acquire前)，确保后续操作不重排到加载前 |
| `memory_order_release` | 高   | 存储         | 阻止先前操作后移(Store-Store,Load-Store不重排到Release后)，确保先前操作不重排到存储后 |
| `memory_order_acq_rel` | 中   | 自旋锁、CAS  | 阻止操作前移或后移(操作前后均不重排)，同时具备`acquire`和`release`语义；用于读-改-写操作 |
| `memory_order_seq_cst` | 最低 | 任意原子操作 | 全局无重排(所有Seq-CST操作按单一全局顺序执行)，所有线程看到一致的操作顺序(默认选项) |

* 注1：`acquire`必须与 `release` 或 `acq_rel` 配对，否则无法保证同步效果(生产者-消费者模型)
* 注2：避免 `consume` 因语义复杂且编译器支持有限，C++17后建议用 `acquire` 替代
* 注3：无锁数据结构(无锁队列) 选 `acq_rel`

```cxx
std::atomic<bool> ready(false);
int data = 0;

void producer() {
    data = 42; // 非原子写
    ready.store(true, std::memory_order_release); // 写屏障，确保data可见
}

void consumer() {
    while (!ready.load(std::memory_order_acquire)); // 读屏障，等待data就绪
    std::cout << data; // 安全读取 data=42
}
```

## 日期与时间(C++)

`std::chrono` 是C++11引入的标准时间库，位于 `<chrono>` 头文件中，主要分为3大类：时钟、时间点、时长，C++20 又新增日历和时区。

| 组件   | 核心功能                                         | 典型应用场景            |
| ------ | -----------------------------------------------  | ----------------------  |
| 时钟   | 提供时间基准(系统/单调/高精度)                   | 性能测试、日历时间获取  |
| 时间点 | 绝对时间点操作，表示某一时刻，基于特定时钟的起点 | 任务调度、超时检测      |
| 时长   | 时间间隔表示与运算，由数值类型和时间单位构成     | 延时设置、时间计算      |

### 时钟(std::chrono::xxx_clock)

| 时钟类型                | 特性                                                 | 适用场景          |
|------------------------ |----------------------------------------------------- | ----------------- |
| `system_clock`          | 日历时钟，唯一有能力映射其时间点到C风格时间的C++时钟 | 获取当前日期/时间(UTC) |
| `steady_clock`          | 单调时钟，时钟的时间单调递增，是系统启动后运行时间   | 性能测量、计时器 |
| `high_resolution_clock` | 高精度时钟(通常是 `steady_clock` 别名，也可能是其它) | 微秒级高精度计时 |

* 注：`system_clock` 可能涉及系统调用，开销较大；`steady_clock` 通常基于硬件计数器，性能更高

* 所有时钟都具有下列成员
    ```cxx
    std::chrono::duration<rep, period> duration; // 时长，rep 计数次数，period std::ratio 计数单位
    std::chrono::time_point<std::chrono::xxx_clock> time_point; // 时间点
    ```

* 所有时钟都提供 `now()` 静态函数，获取当前时间点
    ```cxx
    static std::chrono::time_point<T> now();
    ```
    * 例子
        ```cxx
        /* 时间差测量：使用 `high_resolution_clock` 高精度时钟 */
        using namespace std::chrono;
        auto start = high_resolution_clock::now(); // 当前时间
        process_data();  // 待测函数
        auto end = high_resolution_clock::now();
        auto dur = duration_cast<nanoseconds>(end - start);
        std::cout << "平均耗时：" << dur.count() / 1000 << " ns/次" << endl;
        ```

* 仅 `system_clock` 支持到 `time_t` 的相互转换
    ```cxx
    static std::time_t to_time_t(const std::chrono::system_clock::time_point& t);
    static std::chrono::system_clock::time_point from_time_t(std::time_t t);
    static std::duration time_since_epoch() const;
    ```
    * 例子
        ```cxx
        using namespace std::chrono;
        auto const now = system_clock::now();
        std::time_t newt = system_clock::to_time_t(now);

        auto since_epoch = now.time_since_epoch();
        auto duration_sec = duration_cast<seconds>(since_epoch);
        auto duration_nsec = duration_cast<nanoseconds>(since_epoch - duration_sec);
        std::cout << "UTC：秒=" << duration_sec.count() << " 纳秒=" << duration_nsec.count() << endl;
        ```

### 时间点(std::chrono::time_point)

```cxx
template<class Clock, class Duration = typename Clock::duration> class time_point;
```

* 表示某一时刻，基于特定时钟的起点，
* 支持加减类和比较类运算，不同时钟的 `time_point` 不能直接运算

### 时长(std::chrono::duration)

```cxx
template<class Rep, class Period = std::ratio<1>> class duration;

/* 实现上duration基本都是int64_t，从days开始为C++20定义 */
std::chrono::nanoseconds    // 纳秒，std::chrono::duration</* int64 */, std::nano>
std::chrono::microseconds   // 微妙，std::chrono::duration</* int55 */, std::micro>
std::chrono::milliseconds   // 毫秒，std::chrono::duration</* int45 */, std::milli>
std::chrono::seconds        // 秒，std::chrono::duration</* int35 */>
std::chrono::minutes        // 分，std::chrono::duration</* int29 */, std::ratio<60>>
std::chrono::hours          // 时，std::chrono::duration</* int23 */, std::ratio<3600>>
std::chrono::days           // 日，std::chrono::duration</* int25 */, std::ratio<86400>>
std::chrono::weeks          // 星期，std::chrono::duration</* int22 */, std::ratio<604800>>
std::chrono::months         // 月，std::chrono::duration</* int20 */, std::ratio<2629746>>
std::chrono::years          // 年，std::chrono::duration</* int17 */, std::ratio<31556952>>
```

* 例子：得到时间段大小
    ```cxx
    using namespace std::chrono;
    seconds sec(5);             // 5 秒
    milliseconds ms(250);       // 250 毫秒
    auto total = hours(1) + minutes(30);        // 1 小时 30 分钟
    auto ms = duration_cast<milliseconds>(sec); // 5000 毫秒(显式转换)

    /* 无精度损失的整数尺度转换：无转型 */
    std::cout << milliseconds(sec(1)).count() << " 毫秒\n"
              << microseconds(sec(1)).count() << " 微秒\n"
              << nanoseconds(sec(1)).count()  << " 纳秒\n";
    /* 有精度损失的整数尺度转换：需要转型 */
    std::cout << duration_cast<minutes>(sec(1)).count() << " 分\n";
    ```
* 精确控制线程暂停
    ```cpp
    std::this_thread::sleep_for(milliseconds(100));  // 睡眠100ms
    std::this_thread::sleep_until(system_clock::now() + seconds(5));  // 睡到5秒后
    ```

## STL容器(C++)

* 选型建议
    * 连续内存优先：vector和array因缓存局部性，在遍历和随机访问中碾压链表
    * 动态扩容策略：vector双倍扩容 vs deque分段扩容，后者更适合频繁头尾操作
    * 哈希表 vs 红黑树：无序容器查询更快但内存占用高；有序容器支持范围查询且内存紧凑
    * 链表轻量化：forward_list比list节省33%内存，但牺牲了双向遍历和size()
    * 实际选型时，结合操作频率(插入/访问)、内存限制及排序需求，优先验证vector和unordered_map，再按需升级到特殊容器

* 自定义分配器有两个主要元素需要实现
    * `T* allocate(std::size_t n);` 分配内存
    * `void deallocate(T* p, std::size_t n);` 释放内存
    * 例子：

    ```cxx
    template <typename T, std::size_t N>
    class StackAllocator {
    private:
        alignas(alignof(T)) char buffer_[N * sizeof(T)]; // 栈内存缓冲区
        T* current_ = reinterpret_cast<T*>(buffer_);

    public:
        T* allocate(std::size_t n) {
            if (current_ + n > reinterpret_cast<T*>(buffer_ + sizeof(buffer_))) {
                throw std::bad_alloc();
            }
            T* ptr = current_;
            current_ += n;
            return ptr;
        }
        void deallocate(T*, std::size_t) noexcept {} // 栈内存无需手动释放
    };

    // 使用示例
    std::vector<int, StackAllocator<int, 10>> vec;
    vec.push_back(1);  // 数据存储在栈上
    ```

### 序列容器(连续存储)

```cxx
template<class T, std::size_t N> struct array;
template<class T, class Allocator = std::allocator<T>> class vector;
template<class T, class Allocator = std::allocator<T>> class deque;
template<class CharT, class Traits = std::char_traits<CharT>, class Allocator = std::allocator<CharT>> class basic_string;
using std::string = std::basic_string<char>;
```

| 容器   | 核心特性 | 时间复杂度 | 适用场景 |
| ------ | -------- | ---------- | -------- |
| array  | 固定大小数组，编译时确定尺寸，栈上分配内存 | 随机访问：O(1)<br>插入/删除：不支持 | 元素数量固定、需高性能随机访问 |
| vector | 动态数组，尾部操作高效，内存连续 | 随机访问：O(1)<br>尾部插入/删除：O(1)<br>中间插入/删除：O(n) | 频繁随机访问、尾部操作为主 |
| deque  | 双端队列，分段连续存储(多块固定数组) | 随机访问：O(1)(略慢于vector)<br>头尾插入/删除：O(1)<br>中间操作：O(n) | 需高效头尾操作(如消息队列、滑动窗口) |
| string | 动态字符数组，核心是vector | 随机访问：O(1)<br>尾部插入/删除：O(1)<br>中间插入/删除：O(n) | 替代C传统字符串，提供高效字符操作 |

注：`std::vector<bool>` ：特化的“非标准”容器，行为与其他vector不同：元素存储为单个位(压缩存储)；返回代理引用(reference)而非 `bool&` 。

### 序列容器(链表存储)

```cxx
template<class T, class Allocator = std::allocator<T>> class list;
template<class T, class Allocator = std::allocator<T>> class forward_list;
```

| 容器   | 核心特性 | 时间复杂度 | 适用场景 |
| ------ | -------- | ---------- | -------- |
| list   | 双向链表，任意位置操作高效 | 插入/删除：O(1)<br>随机访问：O(n) | 频繁任意位置插入/删除 |
| forward_list | 单向链表(C++11)，内存占用比list少33%，无size()方法 | 插入/删除：O(1)(仅支持前向操作)<br>随机访问：O(n) | 内存敏感、仅需前向遍历 |

### 序列容器(派生容器)

```cxx
template<class T, class Container = std::deque<T>> class stack;
template<class T, class Container = std::deque<T>> class queue;
template<class T, class Container = std::vector<T>, class Compare = std::less<typename Container::value_type>> class priority_queue;
```

| 容器   | 核心特性 | 默认基于容器 | 可替换容器 | 时间复杂度(关键操作) | 适用场景 |
| ------ | -------- | ------------ | ---------- | -------------------- | -------- |
| stack | 后进先出(LIFO)<br>仅操作栈顶 | deque | vector、list | push(): O(1)<br>pop(): O(1)<br>top(): O(1) | 函数调用栈<br>括号匹配<br>DFS回溯算法 |
| queue | 先进先出(FIFO)<br>队尾插入、队首删除 | deque | list | push(): O(1)<br>pop(): O(1)<br>front()/back(): O(1) | 任务队列<br>BFS遍历<br>消息缓冲 |
| priority_queue | 优先级排序(默认最大堆)<br>堆结构维护 | vector | deque(需支持随机访问) | push(): O(log n)<br>pop(): O(log n)<br>top(): O(1) | 任务调度<br>Dijkstra算法️<br>TopK问题 |

### 有序关联容器(红黑树实现)

```cxx
template<class Key, class T, class Compare = std::less<Key>, class Allocator = std::allocator<std::pair<const Key, T>>> class map;
template<class Key, class T, class Compare = std::less<Key>, class Allocator = std::allocator<std::pair<const Key, T>>> class multimap;
template<class Key, class Compare = std::less<Key>, class Allocator = std::allocator<Key> > class set;
template<class Key, class Compare = std::less<Key>, class Allocator = std::allocator<Key> > class multiset;
```

* 基于红黑树(自平衡二叉搜索树)，元素按Key自动排序
    * 必须定义Key的比较规则(默认 `std::less` )
    * 遍历结果为升序序列，适合范围查询
    * 自定义 `std::less` 需要实现静态成员函数 `constexpr bool operator()(const T& lhs, const T& rhs) const;` 的类
        * 若 `lhs < rhs` 则为 `true` ，否则为 `false`


| 容器   | 核心特性 | 重复Key | 操作时间复杂度 | 适用场景 |
| ------ | -------- | --------| -------------- | -------- |
| map    | Key-Value映射(Key唯一) | ❌ | 插入/删除/查找：O(log n) | 键值对字典 |
| multimap | Key-Value映射(Key可重复) | ✅ | 同上 | 一键多值映射 |
| set    | 唯一Key集合 | ❌   | 同上 | 需有序且去重的集合 |
| multiset | 允许重复Key | ✅ | 同上 | 允许重复的有序集合 |

* `std::pair<T1, T2>` ：关联容器存储的是键值对类型
    * `first` / `second` ：表示第1/2个成员的引用
        * 比较操作按字典序比较，先 first 后 second
    * `std::pair<int, std::string> p1{1, "Apple"};` ：列表初始化
    * `auto p2 = std::make_pair(2, "Banana");` ：make_pair 自动推导初始化
    * `auto [key, value] = p1;` ：结构化绑定，此时key=1, value="Apple"(C++17)

### 无序关联容器(哈希表实现)

```cxx
template<class Key, class T, class Hash = std::hash<Key>, class KeyEqual = std::equal_to<Key>, class Allocator = std::allocator<std::pair<const Key, T>>> class unordered_map;
template<class Key, class T, class Hash = std::hash<Key>, class KeyEqual = std::equal_to<Key>, class Allocator = std::allocator<std::pair<const Key, T>>> class unordered_multimap;
template<class Key, class Hash = std::hash<Key>, class KeyEqual = std::equal_to<Key>, class Allocator = std::allocator<Key>> class unordered_set;
template<class Key, class Hash = std::hash<Key>, class KeyEqual = std::equal_to<Key>, class Allocator = std::allocator<Key>> class unordered_multiset;
```

* 基于哈希表(Bucket数组+链表/红黑树)，元素无序但访问高效
    * Key需支持std::hash特化(或自定义哈希函数)
    * 需重载 `operator==` 解决哈希冲突
    * 自定义 `std::equal_to` 需要实现静态成员函数 `constexpr bool operator()(const T& lhs, const T& rhs) const;` 的类
        * 若 `lhs == rhs` 则为 `true` ，否则为 `false`

| 容器   | 核心特性 | 重复Key | 平均时间复杂度 | 最坏情况 | 适用场景 |
| ------ | -------- | --------| -------------- | -------- | -------- |
| unordered_map | Key-Value映射(Key唯一) | ❌ |  插入/删除/查找：O(1) | O(n) | 高频键值访问 |
| unordered_multimap | Key-Value映射(Key可重复) | ✅ | 同上 | 同上 | 一键多值的快速映射 |
| unordered_set | 唯一Key集合 | ❌ | 同上 | 同上 | 快速去重查询 |
| unordered_multiset | 允许重复Key | ✅ | 同上 | 同上 | 允许重复的快速集合 |

## STL容器操作(C++)

**注：下面迭代器描述中，V为容器类型，T为容器的元素类型**，例如 `std::vector<int>::iterator` ，V为 `std::vector<int>` ，T为 `int` 。

### 迭代器

迭代器是一种检查容器内元素并遍历元素的数据类型，各容器类都定义了自己的iterator类型，用于访问容器内的元素。C++20新增 `std::ranges` 标准库操作迭代器(例如 `v.begin()` 等效 `std::ranges(v)` )。

* 正向迭代器
    * 返回指向起始元素的正向迭代器
        ```cxx
        V::iterator begin();    // 返回普通迭代器，通过解引用( `*it` )或指针访问( `it->member` )可修改容器元素
        V::const_iterator begin() const; // 返回常量迭代器，解引用后仅能读取元素
        V::const_iterator cbegin() const noexcept; // 返回常量迭代器，解引用后仅能读取元素(C++11)
        ```
    * 返回指向尾后元素的正向迭代器
        * 迭代器等于此值时代表迭代完成
        * 此元素表现为占位符，不指向任何元素，解引用访问它导致未定义行为
        ```cxx
        V::iterator end();
        V::const_iterator end() const;
        V::const_iterator cend() const noexcept;
        ```
<br>

* 反向迭代器
    * 返回指向末尾元素的反向迭代器
        ```cxx
        V::reverse_iterator rbegin();
        V::const_reverse_iterator rbegin() const;
        V::const_reverse_iterator crbegin() const noexcept;
        ```
    * 返回指向首前元素的反向迭代器
        * 迭代器等于此值时代表迭代完成
        * 此元素表现为占位符，不指向任何元素，解引用访问它导致未定义行为
        ```cxx
        V::reverse_iterator rend();
        V::const_reverse_iterator rend() const;
        V::const_reverse_iterator crend() const noexcept;
        ```
    * 不支持反向的迭代器
        * 单向链表：forward_list
        * 无序关联容器(哈希表)：unordered_set、unordered_map、unordered_multiset、unordered_multimap
        * 流迭代器：istream_iterator(输入流)、ostream_iterator(输出流)
<br>

* 迭代器遍历
    * 迭代器运算
        * `*iter` ：使用解引用运算符来访问迭代器所指向的元素
        * `++iter` ：使用自增运算符移动迭代器指向容器中下一个元素，等效 `std::next(iter)`
        * `iter1 == iter2` `iter1 != iter2` ：使用比较运算符比较两个迭代器对象是否指向同一个元素
        * `iter1 + n` `iter1 - n` ：使用加减运算符加减一个数值向前/向后移动，指向新的元素
        * `iter1 - iter2` ：使用减法运算符相减计算两个迭代器对象的距离(数值)
    * 遍历不改变元素个数
        ```cxx
        for (auto it = T.begin(); it != T.end(); ++it) {
            // 操作元素值： *it
            // 操作元素成员： it->member

            /* 关联容器(map类)迭代器解引用得到pair<const key, value> */
            // 操作map类型的key： it->first
            // 操作map类型的value： it->second
        }
        ```
    * 遍历删除元素个数
        ```cxx
        for (auto it = T.begin(); it != T.end(); ) {
            if (条件) {
                it = T.erase(it);  // erase返回下一个有效迭代器
            } else {
                ++it;
            }
        }
        ```

### 容量操作

| 容器操作          | empty | size |max_size|rehash |reserve|capacity|shrink_to_fit|
| --------          | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| vector            | ✅    | ✅    | ✅    |       | ✅    | ✅    | ✅    |
| deque             | ✅    | ✅    | ✅    |       |       |       | ✅    |
| array             | ✅    | ✅    | ✅    |       |       |       |       |
| string            | ✅    | ✅    | ✅    |       | ✅    | ✅    | ✅    |
| queue             | ✅    | ✅    |       |       |       |       |       |
| stack             | ✅    | ✅    |       |       |       |       |       |
| priority_queue    | ✅    | ✅    |       |       |       |       |       |
| list              | ✅    | ✅    | ✅    |       |       |       |       |
| forward_list      | ✅    |       | ✅    |       |       |       |       |
| map               | ✅    | ✅    | ✅    |       |       |       |       |
| multimap          | ✅    | ✅    | ✅    |       |       |       |       |
| set               | ✅    | ✅    | ✅    |       |       |       |       |
| multiset          | ✅    | ✅    | ✅    |       |       |       |       |
| unordered_map     | ✅    | ✅    | ✅    | ✅    | ✅    |       |       |
| unordered_multimap| ✅    | ✅    | ✅    | ✅    | ✅    |       |       |
| unordered_set     | ✅    | ✅    | ✅    | ✅    | ✅    |       |       |
| unordered_multiset| ✅    | ✅    | ✅    | ✅    | ✅    |       |       |

* `empty` ：检查容器是否为空
    * `bool empty() const;` ：若容器为空返回true，否则返回false
* `size` ：返回元素数
    * `size_type size() const;` ：返回容器中的元素数，即 `std::distance(begin(), end())`
* `max_size` ：返回可容纳的最大元素数
    * `size_type max_size() const;` ：返回容器根据系统或库实现限制而可保有的元素最大数量
* `rehash` ：
* `rehash` ：预留hashmap类容器预留桶空间
    * `void rehash(size_type count);` ：为hashmap类容器预留至少指定数量的桶并重新生成散列表
* `reserve` ：预留存储空间
    * `void reserve(size_type new_cap);` ：增加容器的容量到大于或等于new_cap的值；或为hashmap类容器预留至少指定数量的元素空间并重新生成散列表
        * 如果new_cap大于当前的 `capacity()`，那么就会分配新存储(迭代器和所有引用均会失效)，否则该方法不做任何事
        * `reserve()` 不会更改容器的大小 `size()`
* `capacity` ：返回当前存储空间能够容纳的元素数
    * `size_type capacity() const;` ：返回当前存储空间能够容纳的元素数
* `shrink_to_fit` ：请求移除未使用的容量
    * `void shrink_to_fit();` 通过释放未使用的内存减少内存的使用，减少 `capacity()` 到 `size()` 非强制性请求，请求是否达成依赖于实现

### 元素查找操作

| 容器操作          | count | find |contains|equal_range|lower_bound|upper_bound|
| ----------------- | :---: | :---: | :---: | :---: | :---: | :---: |
| map               | ✅    | ✅    | ✅    | ✅    | ✅    | ✅    |
| multimap          | ✅    | ✅    | ✅    | ✅    | ✅    | ✅    |
| set               | ✅    | ✅    | ✅    | ✅    | ✅    | ✅    |
| multiset          | ✅    | ✅    | ✅    | ✅    | ✅    | ✅    |
| unordered_map     | ✅    | ✅    | ✅    | ✅    |       |       |
| unordered_multimap| ✅    | ✅    | ✅    | ✅    |       |       |
| unordered_set     | ✅    | ✅    | ✅    | ✅    |       |       |
| unordered_multiset| ✅    | ✅    | ✅    | ✅    |       |       |

注：查找操作只对关联容器有效，序列容器不支持查找操作

* `count` ：返回匹配特定键的元素数量
    * `size_type count(const Key& key) const;` ：返回比较等于key键的元素数
* `find` ：寻找带有特定键的元素，返回迭代器(结果等于 `T.end()` 表示未找到)
    ```cxx
    V::iterator find(const Key& key);
    V::const_iterator find(const Key& key) const;
    ```
* `contains` ：检查容器是否含有带特定键的元素(C++20)
    * `bool contains(const Key& key) const;` ：含有返回true，不含返回false
<br>

* `equal_range` ：返回匹配特定键的元素范围
    * 开始迭代器属于匹配元素，结束迭代器不属于匹配元素
    ```cxx
    std::pair<V::iterator, V::iterator> equal_range(const Key& key);
    std::pair<V::const_iterator, V::const_iterator> equal_range(const Key& key) const;
    ```
* `lower_bound` ：返回指向首个不小于给定键的元素的迭代器
    ```cxx
    std::pair<V::iterator, V::iterator> lower_bound(const Key& key);
    std::pair<V::const_iterator, V::const_iterator> lower_bound(const Key& key) const;
    ```
* `upper_bound` ：返回指向首个大于给定键的元素的迭代器
    ```cxx
    std::pair<V::iterator, V::iterator> upper_bound(const Key& key);
    std::pair<V::const_iterator, V::const_iterator> upper_bound(const Key& key) const;
    ```

### 元素访问操作

| 容器操作          | at    | `[]`  | back  | front | data  |
| ----------------- | :---: | :---: | :---: | :---: | :---: |
| vector            | ✅    | ✅    | ✅    | ✅    | ✅    |
| deque             | ✅    | ✅    | ✅    | ✅    |       |
| array             | ✅    | ✅    | ✅    | ✅    | ✅    |
| string            | ✅    | ✅    | ✅    | ✅    | ✅    |
| queue             |       |       | ✅    | ✅    |       |
| stack             |       |       | top   |       |       |
| priority_queue    |       |       |       | top   |       |
| list              |       |       | ✅    | ✅    |       |
| forward_list      |       |       |       | ✅    |       |
| map               |  ✅   | ✅    |       |       |       |
| multimap          |       |       |       |       |       |
| set               |       |       |       |       |       |
| multiset          |       |       |       |       |       |
| unordered_map     |  ✅   | ✅    |       |       |       |
| unordered_multimap|       |       |       |       |       |
| unordered_set     |       |       |       |       |       |
| unordered_multiset|       |       |       |       |       |

注：`stack` / `priority_queue` 中同样操作意义的函数名不同。

* 随机访问元素
    * `at` / `operator[]`：访问指定序号或key的元素，返回引用
        * 序列容器
            * `at` 带越界检查，越界访问抛出 `std::out_of_range` 异常
            * `[]` 越界访问是未定义的行为

            ```cxx
            T& at(size_type pos);
            const T& at(size_type pos) const;
            T& operator[](size_type pos);
            const T& operator[](size_type pos) const;
            ```
        * `map` / `unordered_map`
            * `at` 带有效性检查，访问未找到元素抛出 `std::out_of_range` 异常
            * `[]` 不存在拥有键key的元素时会新增元素并返回它的引用

            ```cxx
            T& at(const Key& key);
            const T& at(const Key& key) const;
            T& operator[](const Key& key);
            T& operator[](Key&& key);(C++11)
            ```
<br>

* 访问尾元素或栈顶元素
    * 如果 `empty()` 是 `true` ，那么行为未定义
    * `back` ：访问序列容器的尾元素，返回引用
        ```cxx
        T& back();
        const T& back() const;
        ```
    * `top` ：访问stack栈顶元素，返回引用
        ```cxx
        T& top();
        const T& top() const;
        ```
<br>

* 访问首元素或队首元素
    * 如果 `empty()` 是 `true` ，那么行为未定义
    * `front` ：访问序列容器的首元素，返回引用
        ```cxx
        T& front();
        const T& front() const;
        ```
    * `top` ：访问priority_queue队首元素，返回引用
        * 若使用默认比较函数，则返回的元素亦为优先队列中最大的元素
        ```cxx
        const T& top() const;
        ```
<br>

* 访问底层存储空间
    * `data` ：直接访问底层连续存储，返回指针
        ```cxx
        T* data();
        const T* data() const;
        ```

### 插入操作

| 容器操作 |insert|emplace|insert_range|push_back|emplace_back|append_range|push_front|emplace_front|prepend_range|insert_or_assign|emplace_hint|try_emplace|
| --------          | :---: | :---: | :---: | :----: | :---: | :---: | :----: | :---: | :---: | :----: | :---: | :---: |
| vector            | ✅    | ✅    | ✅    |  ✅    | ✅    | ✅    |        |       |       |        |       |       |
| deque             | ✅    | ✅    | ✅    |  ✅    | ✅    | ✅    | ✅     | ✅    | ✅    |        |       |       |
| array             |       |       |       |        |       |       |        |       |       |        |       |       |
| string            | ✅    |       | ✅    |  ✅    |       | ✅    |        |       |       |        |       |       |
| queue             |       |       |       | push   |emplace|push_range|     |       |       |        |       |       |
| stack             |       |       |       | push   |emplace|push_range|     |       |       |        |       |       |
| priority_queue    | push  | ✅    |push_range|     |       |       |        |       |       |        |       |       |
| list              | ✅    | ✅    | ✅    |  ✅    | ✅    | ✅    | ✅     | ✅    | ✅    |        |       |       |
| forward_list      | after | after | after |        |       |       | ✅     | ✅    | ✅    |        |       |       |
| map               | ✅    | ✅    | ✅    |        |       |       |        |       |       | ✅     | ✅    | ✅    |
| multimap          | ✅    | ✅    | ✅    |        |       |       |        |       |       |        | ✅    |       |
| set               | ✅    | ✅    | ✅    |        |       |       |        |       |       |        | ✅    |       |
| multiset          | ✅    | ✅    | ✅    |        |       |       |        |       |       |        | ✅    |       |
| unordered_map     | ✅    | ✅    | ✅    |        |       |       |        |       |       | ✅     | ✅    | ✅    |
| unordered_multimap| ✅    | ✅    | ✅    |        |       |       |        |       |       |        | ✅    |       |
| unordered_set     | ✅    | ✅    | ✅    |        |       |       |        |       |       |        | ✅    |       |
| unordered_multiset| ✅    | ✅    | ✅    |        |       |       |        |       |       |        | ✅    |       |

注：`forward_list` 中的after指的是对应的 `xxx_after` 版本。`queue` / `stack` / `priority_queue` 中同样操作意义的函数名不同。

* 随机插入元素
    * 大多数序列容器 (插入到指定元素前)
        * `insert` ：插入元素，返回指向(首个)被插入元素的迭代器(插入0个元素时返回pos)
        * `emplace` ：原地构造元素，返回指向原地构造插入元素的迭代器(C++11)
        * `insert_range` ：插入元素范围(C++23)

        ```cxx
        V::iterator insert(V::const_iterator pos, const T& value); // 在pos前插入value的副本
        V::iterator insert(V::const_iterator pos, T&& value); // 在pos前插入value(移动语义)
        V::iterator insert(V::const_iterator pos, size_type count, const T& value); // 在pos前插入value的count个副本
        template<class InputIt>
        V::iterator insert(V::const_iterator pos, InputIt first, InputIt last); // 在pos前插入来自范围 `[first, last)` 的元素
        V::iterator insert(V::const_iterator pos, std::initializer_list<T> ilist); // 在pos前插入来自初始化器列表ilist的元素

        template<class... Args>
        V::iterator emplace(V::const_iterator pos, Args&&... args); // 在pos前原地构造插入元素，args为转发给元素构造函数的参数
        ```

    * `priority_queue` (插入后调整顺序)
        * `push` ：向queue尾部或stack栈顶插入元素
        * `emplace ` ：在queue尾部或stack栈顶原地构造元素
        * `push_range` ：在queue尾部或stack栈顶插入元素范围
        ```cxx
        void push(const T& value);
        void push(T&& value);

        template<class... Args>
        void emplace(Args&&... args );
        ```

    * `forward_list` (插入到指定元素后)
        * `insert_after` ：在某个元素后插入元素，返回指向(最后一个)被插入元素的迭代器(插入0个元素时返回pos)
        * `emplace_after` ：在某个元素后原地构造元素(C++11)
        * `insert_range_after` ：在某个元素后插入元素范围(C++23)
        ```cxx
        V::iterator insert_after(V::const_iterator pos, const T& value);
        V::iterator insert_after(V::const_iterator pos, T&& value);
        V::iterator insert_after(V::const_iterator pos, size_type count, const T& value);
        template<class InputIt>
        V::iterator insert_after(V::const_iterator pos, InputIt first, InputIt last);
        V::iterator insert_after(V::const_iterator pos, std::initializer_list<T> ilist);

        template<class... Args>
        V::iterator emplace(V::const_iterator pos, Args&&... args);
        ```

    * 非multi关联容器 ：完成插入返回的pair.second为true
        * `insert` ：插入元素，若未含有带等价键的元素则插入元素到容器中，**否则什么都不做**
        * `emplace` ：原地构造元素，若未含有带等价键的元素则原地构造插入元素到容器中，否则什么都不做(C++11)
        * `try_emplace` ：原地构造元素，若未含有带等价键的元素则原地构造插入元素到容器中，否则什么都不做(C++17)
        * `insert_or_assign` ：插入元素，若未含有带等价键的元素则插入元素到容器中，**否则赋值给当前元素** (C++17)
        * `insert_range` ：插入元素范围(C++23)
        * `emplace_hint` ：使用提示原地构造元素(C++11)

        ```cxx
        std::pair<V::iterator, bool> insert(const T& value);
        std::pair<V::iterator, bool> insert(T&& value);
        template<class InputIt>
        void insert(InputIt first, InputIt last);
        void insert(std::initializer_list<T> ilist);

        template<class... Args>
        std::pair<V::iterator, bool> emplace(Args&&... args);

        std::pair<V::iterator, bool> insert_or_assign(const Key& key, ST&& obj);
        std::pair<V::iterator, bool> insert_or_assign(Key&& key, ST&& obj);

        template<class... Args>
        std::pair<V::iterator, bool> try_emplace(const Key& key, Args&&... args);
        template<class... Args>
        std::pair<V::iterator, bool> try_emplace(Key&& key, Args&&... args);
        ```

    * multi关联容器
        * `insert` ：插入元素，不关心键值是否重复
        * `emplace` ：原地构造元素，不关心键值是否重复(C++11)

        ```cxx
        V::iterator insert(const T& value);
        V::iterator insert(T&& value);
        template<class InputIt>
        void insert(InputIt first, InputIt last);
        void insert(std::initializer_list<T> ilist);

        template<class... Args>
        V::iterator emplace(Args&&... args);
        ```
<br>

* 尾部插入元素
    * 大多数序列容器
        * `push_back` ：将元素添加到容器末尾
        * `emplace_back` ：在容器末尾原地构造元素(C++11)
        * `append_range` ：添加元素的范围到末尾(C++23)
        ```cxx
        void push_back(const T& value);
        void push_back(T&& value);

        template<class... Args>
        T& emplace_back(Args&&... args); // C++17前无返回值，C++17及之后返回插入元素的引用
        ```

    * `std::queue` 和 `std::stack`
        * `push` ：向queue尾部或stack栈顶插入元素
        * `emplace ` ：在queue尾部或stack栈顶原地构造元素
        * `push_range` ：在queue尾部或stack栈顶插入元素范围
        ```cxx
        void push(const T& value);
        void push(T&& value);

        template<class... Args>
        T& emplace(Args&&... args); // C++17前无返回值，C++17及之后返回插入元素的引用
        ```
<br>

* 首部插入元素
    * `deque` `list` `forward_list`
        * `push_front` ：插入元素到容器起始
        * `emplace_front` ：在容器头部原地构造元素(C++11)
        * `prepend_range` ：添加元素的范围到起始(C++23)
        ```cxx
        void push_front(const T& value);
        void push_front(T&& value);
        template<class... Args>
        T& emplace_front(Args&&... args); // C++17前无返回值，C++17及之后返回插入元素的引用
        ```

### 移除操作

| 容器操作          | clear | erase|pop_back|pop_front|extract|
| ----------------- | :---: | :---: | :---: | :----: | :---: |
| vector            | ✅    | ✅    | ✅    |        |       |
| deque             | ✅    | ✅    | ✅    | ✅     |       |
| array             |       |       |       |        |       |
| string            | ✅    | ✅    | ✅    |        |       |
| queue             |       |       |       | pop    |       |
| stack             |       |       | pop   |        |       |
| priority_queue    |       |       |       | pop    |       |
| list              | ✅    | ✅    | ✅    | ✅     |       |
| forward_list      | ✅    | after |       | ✅     |       |
| map               | ✅    | ✅    |       |        | ✅    |
| multimap          | ✅    | ✅    |       |        | ✅    |
| set               | ✅    | ✅    |       |        | ✅    |
| multiset          | ✅    | ✅    |       |        | ✅    |
| unordered_map     | ✅    | ✅    |       |        | ✅    |
| unordered_multimap| ✅    | ✅    |       |        | ✅    |
| unordered_set     | ✅    | ✅    |       |        | ✅    |
| unordered_multiset| ✅    | ✅    |       |        | ✅    |

注：`forward_list` 中的after指的是对应的 `xxx_after` 版本。`queue` / `stack` / `priority_queue` 中同样操作意义的函数名不同。

* 移除所有元素
    * `clear` ：清除内容
        * `void clear();` ：从容器移除所有元素，此调用后 `size()` 返回零
<br>

* 移除指定元素
    * 大多数容器
        * `erase` ：移除指定元素或指定范围的元素，返回最后移除元素之后的迭代器
            * `erase` 是移除 `pos` 或从 `first` 开始移除，不含 `last`
            ```cxx
            V::iterator erase(V::const_iterator pos);
            V::iterator erase(V::const_iterator first, const_iterator last);
            size_type erase(const Key& key); // 仅关联容器支持，返回被移除的元素个数(0是未找到)
            ```
    * `forward_list`
        * `erase_after` ：移除指定元素之后或指定范围的元素，返回指向后随被擦除元素的迭代器
            * `erase_after` 是移除 `std::next(pos)` 或从 `std::next(first)` 开始移除，不含 `last`
            *  例如： `flist.erase_after(flist.before_begin());`  移除首元素
            ```cxx
            V::iterator erase_after(V::const_iterator pos);
            V::iterator erase_after(V::const_iterator first, const_iterator last);
            ```
<br>

* 移除尾元素
    * 大多数序列容器
        * `pop_back` ：移除尾元素，如果 `empty()` 是 true，那么行为未定义
            * `void pop_back();`
    * `stack`
        * `pop` ：移除stack栈顶元素
            * `void pop();`
<br>

* 移除首元素
    * 大多数序列容器
        * `pop_front` ：移除首元素
            * `void pop_front();`
    * `queue` 和  `priority_queue`
        * `pop` ：移除队首元素
            * `void pop();`
<br>

* 提取并移除元素(C++17)
    * `extract` ：提取容器中的节点，返回被提取元素的结点句柄，或找不到元素的情况下返回空结点句柄(仅关联容器支持)
        ```cxx
        node_type extract(V::const_iterator pos);
        node_type extract(const Key& key);
        ```
    * 例子
        ```cxx
        std::map<int, std::string> m{{1, "A"}, {2, "B"}};
        // 提取键为2的节点
        auto nh = m.extract(2);  // m 变为 {{1, "A"}}
        if (!nh.empty()) {
            nh.key() = 3;       // 安全修改键
            m.insert(std::move(nh)); // 重新插入，m = {{1, "A"}, {3, "B"}}
        }
        ```

### 其它操作

| 容器操作          | resize | swap | fill  | merge |splice |remove|remove_if|reverse|unique|sort   |
| ----------------- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| vector            | ✅    | ✅    |       |       |       |       |       |       |       |       |
| deque             | ✅    | ✅    |       |       |       |       |       |       |       |       |
| array             |       |       | ✅    |       |       |       |       |       |       |       |
| string            | ✅    | ✅    |       |       |       |       |       |       |       |       |
| queue             |       | ✅    |       |       |       |       |       |       |       |       |
| stack             |       | ✅    |       |       |       |       |       |       |       |       |
| priority_queue    |       | ✅    |       |       |       |       |       |       |       |       |
| list              | ✅    | ✅    |       | ✅    | ✅    | ✅   |  ✅   | ✅    | ✅    | ✅    |
| forward_list      | ✅    | ✅    |       | ✅    | after | ✅   |  ✅   | ✅    | ✅    | ✅    |
| map               |       | ✅    |       | ✅    |       |       |       |       |       |       |
| multimap          |       | ✅    |       | ✅    |       |       |       |       |       |       |
| set               |       | ✅    |       | ✅    |       |       |       |       |       |       |
| multiset          |       | ✅    |       | ✅    |       |       |       |       |       |       |
| unordered_map     |       | ✅    |       | ✅    |       |       |       |       |       |       |
| unordered_multimap|       | ✅    |       | ✅    |       |       |       |       |       |       |
| unordered_set     |       | ✅    |       | ✅    |       |       |       |       |       |       |
| unordered_multiset|       | ✅    |       | ✅    |       |       |       |       |       |       |

注：`forward_list` 中的after指的是对应的 `xxx_after` 版本。

* `resize` ：改变存储元素的个数
    * 重设容器大小以容纳count个元素
        * `count == size()` 不做任何事
        * `count < size()` 减小容器到它的前count个元素
        * `count > size()` 追加额外的默认插入的元素或value的副本
    ```cxx
    void resize(size_type count);
    void resize(size_type count, const T& value);
    ```

* `swap` ：交换内容
    * `void swap(vector& other) noexcept;`
* `fill` ：以指定值填充容器
    * `void fill(const T& value);` ：将定值value赋给容器中的所有元素
* `merge` ：合并两个有序列表
* `splice` ：从一个容器转移元素给另一个
* `remove` ：移除满足特定标准的元素
* `remove_if` ：移除满足特定标准的元素
* `reverse` ：反转元素的顺序
* `unique` ：删除连续的重复元素
* `sort` ：对元素进行排序

### std::string特有操作

```cxx
#include <string>
using std::string;
```

* string没有以空字符结尾，不是字符串。字符串字面值与标准库 string 类型不是同一种类型

* 几种初始化 string 对象的方式

| 函数 | 说明 |
| ---  | ---  |
| `string s1;`          | 默认构造函数 s1 为空串 |
| `string s2(s1);`      | 将 s2 初始化为 s1 的一个副本 |
| `string s3("value");` | 将 s3 初始化为一个字符串字面值副本 |
| `string s4(n, 'c');`  | 将 s4 初始化为字符 'c' 的 n 个副本 |

* cin 从标准输入读取 string 并将读入的串存储在 s 中。string 类型的输入操作符：
    * 读取并忽略开头所有的空白字符(如空格，换行符，制表符)
    * 读取字符直至再次遇到空白字符，读取终止
    * 如果输入是"Hello World!"
        * `cin >> s;cout << s << endl;` 将输出"Hello"
        * `cin >> s1 >> s2; cout << s1 << s2 << endl;` 输出的结果是"HelloWorld!"而不含任何空格

* getline 函数接受一个 istream 对象和一个 string对象，读取输入流直到下一个换行符，存储读入的输入流到 string 对象中，并返回 istream 对象。换行符被读入并丢弃

    ```cxx
    int main()
    {
        string line;
        // read line at time until end-of-file
        while(getline(cin, line)) {
            cout << line << endl;
        }
        return 0;
    }
    ```

* 常用的 string 操作

| 函数 | 说明 |
| ---  | ---  |
| `s.empty()`            | 如果 s 为空串，则返回 true，否则返回 false |
| `s.size()`             | 返回 s 中字符的个数(string::size_type 类型的值) |
| `s1 + s2`              | 把 s1 和 s2 连接成一个新字符串，返回新生成的字符串 |
| `s1 = s2`              | 把 s1 内容替换为 s2 的副本 |
| `v1 == v2`             | 比较 v1 与 v2 的内容，相等则返回 true，否则返回 false |
|                        | 两个 string 对象相等是指它们的长度相同，且含有相同的字符 |
| `!=` `<` `<=` `>` `>=` | 保持这些操作符惯有的含义 |
| `s.c_str()`            | 返回 C 风格字符串 |

* 关系操作符比较两个 string 对象时采用了和(大小写敏感的)字典排序相同的策略：
    * 如果两个 string 对象长度不同，且短的 string 对象与长的 string 对象的前面部分相匹配，则短的 string 对象小于长的 string 对象
    * 如果 string 对象的字符不同，则比较第一个不匹配的字符
* 当进行 string 对象和字符串字面值混合连接操作时，`+` 操作符的左右操作数必须至少有一个是 string 类型的
* 标准库不要求检查索引值，所用索引的下标越界是没有定义的，这样往往会导致严重的运行时错误
* 在要求 C 风格字符串的地方不可直接使用标准库 string 类型对象，例如，无法使用 string 对象初始化字符指针

* cctype 中的函数

| 函数 | 说明 |
| ---  | ---  |
| `isalnum(c)`  | 如果 c 是字母或数字，则为 true |
| `isalpha(c)`  | 如果 c 是字母，则为 true |
| `iscntrl(c)`  | 如果 c 是控制字符，则为 true |
| `isdigit(c)`  | 如果 c 是数字，则为 true |
| `isgraph(c)`  | 如果 c 不是空格，但可打印，则为 true |
| `islower(c)`  | 如果 c 是小写字母，则为 true |
| `isprint(c)`  | 如果 c 是可打印的字符，则为 true |
| `ispunct(c)`  | 如果 c 是标点符号，则 true |
| `isspace(c)`  | 如果 c 是空白字符，则为 true |
| `isupper(c)`  | 如果 c 是大写字母，则 true |
| `isxdigit(c)` |  如果是 c 十六进制数，则为 true |
| `tolower(c)`  | 如果 c 大写字母，返回其小写字母形式，否则直接返回 c |
| `toupper(c)`  | 如果 c 是小写字母，则返回其大写字母形式，否则直接返回 c |

### std::bitset操作

`std::bitset` 是固定长度的位集，bitset 的长度在编译时确定，无法动态调整，无迭代器，位压缩存储为整型数组节省空间。

```cxx
#include <bitset>
using std::bitset;
```

* 初始化 bitset 对象的方法

| 函数 | 说明 |
| ---  | ---  |
| `bitset<n> b;`            | b 有 n 位，每位都 0，给出的长度值必须是常量表达式 |
| `bitset<n> b(u);`         | b 是 unsigned long 型 u 的一个副本 |
| `bitset<n> b(s);`         | b 是 string 对象 s 中含有的位串的副本 |
| `bitset<n> b(s, pos, n);` | b 是 s 中从位置 pos 开始的 n 个位的副本 |

* 位集合的位置编号从 0 开始。
* 当用 unsigned long 值作为 bitset 对象的初始值时，该值将转化为二进制的位模式。而 bitset 对象中的位集作为这种位模式的副本。
    * 如果 bitset 类型长度大于 unsigned long 值的二进制位数，则其余的高阶位将置为 0；
    * 如果 bitset 类型长度小于 unsigned long 值的二进制位数，则只使用 unsigned 值中的低阶位，超过 bistset 类型长度的高阶位将被丢弃。
* 从 string 对象读入位集的顺序是从右向左。string 对象和 bitsets 对象之间是反向转化的：string 对象的最右边字符(即下标最大的那个字符)用来初始化 bitset 对象的低阶位(即下标为 0 的位)。
* 举例
    `string str("1111111000000011001101");`
    `bitset<32> bitvec5(str, 5, 4); // 4 bits starting at str[5], 1100`
    `bitset<32> bitvec6(str, str.size()-4); // use last 4characters`

* bitset 操作

| 函数 | 说明 |
| ---  | ---  |
| `b.any()`      | b 中是否存在置为 1 的二进制位 |
| `b.none()`     | b 中是否不存在置为 1 的二进制位 |
| `b.count()`    | b 中置为 1 的二进制位的个数 |
| `b.size()`     | b 中二进制位的个数 |
| `b[pos]`       | 访问 b 中在 pos 处二进制位 |
| `b.test(pos)`  | b 中在 pos 处的二进制位置为 1 么 |
| `b.set()`      | 把 b 中所有二进制位都置为 1 |
| `b.set(pos)`   | 把 b 中在 pos 处的二进制位置为 1 |
| `b.reset()`    | 把 b 中所有二进制位都置为 0 |
| `b.reset(pos)` | 把 b 中在 pos 处的二进制位置为 0 |
| `b.flip()`     | 把 b 中所有二进制位逐位取反 |
| `b.flip(pos)`  | 把 b 中在 pos 处的二进制位取反 |
| `b.to_ulong()` | 用 b 中同样的二进制位返回一个 unsigned long 值 |
| `os << b`      | 把 b 中的位集输出到 os 流 |
